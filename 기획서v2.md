# 🎯 암호화폐 자동매매 시스템 - 완전 기획서 v3.0

---

## 📋 목차
1. [프로젝트 개요](#1-프로젝트-개요)
2. [시스템 아키텍처](#2-시스템-아키텍처)
3. [핵심 모듈 상세 설계](#3-핵심-모듈-상세-설계)
4. [데이터 흐름도](#4-데이터-흐름도)
5. [API 통합 명세](#5-api-통합-명세)
6. [거래 로직 상세](#6-거래-로직-상세)
7. [리스크 관리 체계](#7-리스크-관리-체계)
8. [AI 시스템 설계](#8-ai-시스템-설계)
9. [예외 처리 전략](#9-예외-처리-전략)
10. [성능 및 모니터링](#10-성능-및-모니터링)
11. [배포 및 운영](#11-배포-및-운영)

---

## 1. 프로젝트 개요

### 1.1 시스템 목적
- **자동화된 암호화폐 현물 거래**: DOGE/USDT, SOL/USDT 24시간 자동 매매
- **AI 기반 의사결정**: Claude API를 활용한 진입/청산 판단
- **리스크 최소화**: 손실 제한, 트레일링 스톱, 연속 손실 방지
- **학습 기능**: 거래 패턴 분석 및 파라미터 자동 최적화

### 1.2 핵심 사양
```yaml
투자금: 1,000,000 KRW (사용자 설정 가능)
거래소: Bybit 현물
거래 방식: Market Order (즉시 체결)
손익비: 2:1 (익절 +2%, 손절 -1%)
트레일링: +0.5% 도달 시 활성화, 고점 -1% 손절
최대 보유: 24시간 강제 청산
AI 모델: Claude 3 Sonnet
실행 주기: 1분마다 시장 체크
```

### 1.3 모드별 구분
| 모드 | 용도 | 거래소 연결 | AI 사용 | 데이터 |
|------|------|-------------|---------|--------|
| **Paper** | 모의투자 테스트 | 실시간 시세 조회만 | O | 실시간 |
| **Live** | 실거래 | 실제 주문 체결 | O | 실시간 |
| **Backtest** | 과거 검증 | X (CSV 데이터) | X | 과거 |

---

## 2. 시스템 아키텍처

### 2.1 전체 구조도
```
┌─────────────────────────────────────────────────────────┐
│                   실행 레이어 (run_*.py)                  │
│  ┌──────────┐  ┌──────────┐  ┌──────────────┐          │
│  │ run_paper│  │ run_live │  │ run_backtest │          │
│  └────┬─────┘  └────┬─────┘  └──────┬───────┘          │
└───────┼─────────────┼────────────────┼──────────────────┘
        │             │                │
        └─────────────┴────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────┐
│                    엔진 레이어 (engine/)                  │
│  ┌──────────────────────────────────────────────────┐   │
│  │           BaseEngine (공통 로직)                  │   │
│  │  - 초기화 / 메인 루프 / 리스크 체크 / 종료       │   │
│  └────┬─────────────────┬─────────────────┬──────────┘   │
│       │                 │                 │              │
│  ┌────▼──────┐   ┌─────▼──────┐   ┌─────▼──────┐       │
│  │PaperEngine│   │ LiveEngine │   │BacktestEng │       │
│  └───────────┘   └────────────┘   └────────────┘       │
└─────────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────┐
│                  비즈니스 로직 레이어                      │
│ ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │
│ │ Strategy │  │Indicators│  │    AI    │  │  Risk   │ │
│ │  진입/청산│  │ 지표계산  │  │  Claude  │  │ 관리자  │ │
│ └──────────┘  └──────────┘  └──────────┘  └─────────┘ │
└─────────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────────┐
│                   데이터 레이어                           │
│ ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │
│ │ Bybit API│  │  Cache   │  │ Database │  │  Logger │ │
│ └──────────┘  └──────────┘  └──────────┘  └─────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 2.2 디렉토리 구조와 역할
```
crypto-trading-bot/
│
├── core/                    # 🎯 공통 설정 및 상수
│   ├── config.py           # 투자금, 손익비 등 모든 설정
│   ├── api_keys.py         # API 키 관리 및 검증
│   ├── constants.py        # 심볼, 타임프레임 등 상수
│   └── exceptions.py       # 커스텀 예외 정의
│
├── data/                    # 📊 데이터 수집 및 처리
│   ├── fetcher.py          # 실시간 시세/볼륨 수집
│   ├── historical.py       # 백테스트용 과거 데이터
│   ├── processor.py        # 데이터 정제 및 정규화
│   └── cache.py            # 1분간 데이터 캐싱
│
├── indicators/              # 📈 기술적 지표 계산
│   ├── calculator.py       # 통합 계산기 (모든 지표 한번에)
│   ├── rsi.py             # RSI(14)
│   ├── macd.py            # MACD (12, 26, 9)
│   ├── bollinger.py       # 볼린저밴드 (20, 2σ)
│   ├── fibonacci.py       # 피보나치 되돌림
│   └── composite.py       # 복합 신호 생성
│
├── strategy/                # 🎯 거래 전략
│   ├── entry.py           # 진입 신호 (지표 → AI)
│   ├── exit.py            # 청산 신호 (손절/익절/트레일링)
│   ├── trailing.py        # 트레일링 스톱 로직
│   └── signals.py         # 신호 강도 계산
│
├── ai/                      # 🤖 AI 분석 시스템
│   ├── claude_client.py   # Claude API 통신
│   ├── analyzer.py        # 응답 파싱 및 검증
│   ├── prompts.py         # 프롬프트 템플릿 (진입/보유/학습)
│   ├── learner.py         # 패턴 학습 및 개선
│   ├── news_api.py        # 뉴스 수집 (CoinGecko)
│   └── sentiment_api.py   # Fear & Greed Index
│
├── exchanges/               # 💱 거래소 인터페이스
│   ├── base.py            # 추상 클래스
│   ├── bybit_live.py      # 실거래 (ccxt 사용)
│   ├── paper.py           # 모의거래 (가상 잔고)
│   ├── backtest.py        # 백테스트 (CSV 재생)
│   └── order_handler.py   # 부분 체결 처리
│
├── risk/                    # 🛡️ 리스크 관리
│   ├── manager.py         # 통합 관리자
│   ├── position.py        # 포지션 크기 계산 (Kelly)
│   └── limits.py          # 손실 한도 모니터링
│
├── database/                # 💾 데이터베이스
│   ├── models.py          # SQLite 스키마
│   ├── trades.py          # 거래 CRUD
│   └── learning.py        # 학습 데이터 CRUD
│
├── engine/                  # ⚙️ 실행 엔진
│   ├── base_engine.py     # 공통 로직
│   ├── paper_engine.py    # 모의투자
│   ├── live_engine.py     # 실거래
│   └── backtest_engine.py # 백테스트
│
├── monitoring/              # 📊 모니터링 및 로깅
│   ├── logger.py          # 파일 로깅
│   ├── reporter.py        # 일일/주간 리포트
│   └── performance.py     # 성과 추적 (Sharpe, DD)
│
├── utils/                   # 🔧 유틸리티
│   ├── network.py         # 네트워크 재시도
│   ├── fee_calculator.py  # 수수료 계산
│   ├── validators.py      # 데이터 검증
│   └── helpers.py         # 기타 헬퍼
│
├── storage/                 # 📦 데이터 저장소
│   ├── historical/        # 과거 CSV 데이터
│   ├── cache/             # 임시 캐시
│   └── trades.db          # SQLite 파일
│
├── logs/                    # 📝 로그 파일
│   ├── paper/             # 모의투자 로그
│   ├── live/              # 실거래 로그
│   └── backtest/          # 백테스트 로그
│
├── run_paper.py             # 🚀 모의투자 실행
├── run_live.py              # 💰 실거래 실행
├── run_backtest.py          # 📊 백테스트 실행
├── requirements.txt         # 의존성 패키지
├── .env                     # API 키 (gitignore)
├── .env.example             # API 키 템플릿
└── README.md                # 프로젝트 문서
```

---

## 3. 핵심 모듈 상세 설계

### 3.1 core/config.py
**역할**: 모든 설정값 중앙 관리

**주요 설정 항목**:
```python
# 투자 설정
INVESTMENT_AMOUNT = 1_000_000  # KRW
POSITION_ALLOCATION = {'DOGE': 0.5, 'SOL': 0.5}

# 손익 구조
TAKE_PROFIT = 0.02         # +2%
STOP_LOSS = -0.01          # -1%
TRAILING_ACTIVATION = 0.005 # +0.5%
TRAILING_STOP = -0.01       # 고점 -1%

# 리스크 한도
DAILY_LOSS_LIMIT = -0.05    # 일일 -5%
MONTHLY_DD_LIMIT = -0.10    # 월간 -10%
CONSECUTIVE_LOSS_LIMIT = 3  # 연속 3회

# AI 설정
MIN_AI_CONFIDENCE = 0.70    # 최소 신뢰도 70%
AI_CHECK_INTERVAL = 7200    # 2시간마다 체크

# 거래 설정
MAX_HOLDING_TIME = 86400    # 24시간
ORDER_TIMEOUT = 30          # 주문 대기 30초
```

**모드별 로드 방식**:
```python
def load(mode='paper'):
    """
    모드에 따라 다른 설정 적용 가능
    
    paper: 전체 투자금 사용
    live: API 키 검증 + 실잔고 확인
    backtest: AI 비활성화
    """
```

---

### 3.2 core/api_keys.py
**역할**: API 키 관리 및 검증

**필수 키 목록**:
- `BYBIT_API_KEY`: Bybit 공개 키
- `BYBIT_API_SECRET`: Bybit 비밀 키
- `CLAUDE_API_KEY`: Anthropic Claude API 키

**선택 키 목록**:
- `BYBIT_TESTNET`: 테스트넷 사용 여부 (기본: False)
- `CLAUDE_MODEL`: 모델 선택 (기본: claude-3-sonnet-20240229)
- `CLAUDE_MAX_TOKENS`: 응답 길이 (기본: 1024)
- `CLAUDE_TEMPERATURE`: 일관성 (기본: 0.3)

**검증 시점**:
```
1. run_*.py 실행 시 즉시 검증
2. 누락 시 명확한 에러 메시지
3. 잘못된 키는 첫 API 호출 시 감지
```

**에러 처리**:
```python
if not BYBIT_API_KEY:
    raise ValueError("❌ BYBIT_API_KEY 누락. .env 파일 확인")

if not CLAUDE_API_KEY:
    raise ValueError("❌ CLAUDE_API_KEY 누락. https://console.anthropic.com 에서 발급")
```

---

### 3.3 data/fetcher.py
**역할**: 실시간 시장 데이터 수집

**수집 데이터**:
```python
{
    'symbol': 'DOGE/USDT',
    'price': 0.3821,           # 현재가
    'volume_24h': 1234567890,  # 24시간 거래량
    'ohlcv': [                 # 최근 200개 5분봉
        [timestamp, open, high, low, close, volume],
        ...
    ],
    'orderbook': {             # 호가창 (상위 20개)
        'bids': [[price, amount], ...],
        'asks': [[price, amount], ...]
    },
    'timestamp': 1234567890
}
```

**캐싱 전략**:
```
- 1분간 동일 데이터 재사용
- 동일 심볼 중복 호출 방지
- 메모리 캐시 사용 (Redis 불필요)
```

**API 호출 빈도**:
```
심볼당 1분에 1회 → 2개 심볼 = 분당 2회
월간 약 86,400회 → Bybit 무료 한도 내
```

---

### 3.4 indicators/calculator.py
**역할**: 모든 기술적 지표 한번에 계산

**계산 지표 목록**:
```yaml
필수 지표 (4개):
  - RSI(14): 과매수/과매도 판단
  - MACD(12,26,9): 추세 전환 감지
  - Bollinger Bands(20,2σ): 변동성 및 지지/저항
  - Fibonacci: 되돌림 레벨 (0.382, 0.5, 0.618)

추가 지표:
  - EMA(20,50,200): 추세 방향
  - Volume Ratio: 거래량 비율
  - Stochastic RSI: 단기 모멘텀
```

**출력 형식**:
```python
{
    'rsi': {
        'value': 45.2,
        'oversold': False,
        'overbought': False,
        'trend': 'up'
    },
    'macd': {
        'value': 0.0015,
        'signal': 0.0012,
        'histogram': 0.0003,
        'golden_cross': True,
        'momentum': 'bullish'
    },
    'bollinger': {
        'upper': 0.3850,
        'middle': 0.3820,
        'lower': 0.3790,
        'position': 'near_lower',
        'lower_touch': True
    },
    'fibonacci': {
        'support': ('0.618', 0.3800),
        'resistance': ('0.382', 0.3840),
        'at_support': True
    },
    'signal_count': 3  # 충족된 조건 개수
}
```

**성능 최적화**:
```
- pandas_ta 라이브러리 사용 (C 기반)
- 200개 캔들 기준 < 100ms
- 병렬 계산 없이도 충분
```

---

### 3.5 strategy/entry.py
**역할**: 진입 신호 생성 (3단계 필터링)

**진입 프로세스**:
```
Step 1: 기술적 지표 1차 필터 (자동)
├─ RSI < 70 ✓
├─ MACD 골든크로스 ✓
├─ 볼린저 하단 터치 ✓
└─ 피보나치 지지선 ✓
→ 4개 중 최소 3개 충족 필요

Step 2: 추가 지표 확인 (자동)
├─ EMA 정배열 (20>50>200)
├─ 거래량 1.5배 이상
└─ Stochastic RSI 상승

Step 3: AI 최종 판단 (필수)
├─ Claude API 호출
├─ 뉴스/센티먼트 분석
├─ 글로벌 지표 (BTC 방향, Fear & Greed)
└─ ENTER + 신뢰도 ≥ 70% → 진입!
```

**AI 호출 데이터**:
```python
{
    'symbol': 'DOGE/USDT',
    'price': 0.3821,
    'indicators': {...},  # 위 calculator 결과
    'news': [             # 최근 4시간 뉴스
        {'title': '...', 'sentiment': 'positive'},
        ...
    ],
    'market_context': {
        'btc_change_24h': +2.3,
        'fear_greed_index': 65,
        'hour_of_day': 14
    }
}
```

**AI 응답 처리**:
```python
{
    "action": "ENTER" or "WAIT",
    "confidence": 0.75,
    "reasoning": "MACD golden cross with strong volume, positive BTC correlation",
    "key_factors": ["macd", "volume", "btc_trend"],
    "risk_level": "MEDIUM"
}
```

**거부 사유 예시**:
```
- 신뢰도 < 70%: "insufficient confidence"
- 지표 부족: "only 2 out of 4 indicators met"
- 뉴스 부정: "negative news in last 2 hours"
- 시간대 불리: "historically poor performance at this hour"
```

---

### 3.6 strategy/exit.py
**역할**: 청산 신호 생성 (5가지 케이스)

**청산 케이스별 처리**:

**Case 1: 초기 손절 (-1%)**
```python
if current_pnl <= -0.01:
    return {
        'signal': 'EXIT',
        'reason': 'STOP_LOSS',
        'ai_check': False,  # AI 판단 없이 즉시 실행
        'priority': 'CRITICAL'
    }
```

**Case 2: 트레일링 스톱**
```python
if current_price >= entry_price * 1.005:  # +0.5% 도달
    # 트레일링 활성화
    trailing.activate()
    trailing.update_highest(current_price)

if trailing.is_active and current_price <= trailing.stop_price:
    return {
        'signal': 'EXIT',
        'reason': 'TRAILING_STOP',
        'highest_price': trailing.highest,
        'final_pnl': calculate_pnl(),
        'ai_check': False
    }
```

**Case 3: 목표 익절 (+2%)**
```python
if current_pnl >= 0.02:
    # AI에게 "계속 오를까?" 물어봄
    ai_response = await claude.analyze_holding({
        'check_type': 'TARGET_REACHED',
        'current_pnl': 2.0,
        'momentum': indicators['macd']['momentum'],
        'volume_trend': 'increasing'
    })
    
    if ai_response['action'] == 'EXIT':
        return {'signal': 'EXIT', 'reason': 'TARGET_EXIT'}
    else:
        return None  # 트레일링 계속
```

**Case 4: 정기 체크 (2시간마다)**
```python
if holding_time % 7200 < 60:  # 2시간 ± 1분
    ai_response = await claude.analyze_holding({
        'check_type': 'PERIODIC_CHECK',
        'holding_hours': holding_time / 3600,
        'trend_change': check_trend_reversal()
    })
    
    if ai_response['action'] == 'EXIT':
        return {'signal': 'EXIT', 'reason': 'AI_PERIODIC'}
```

**Case 5: 24시간 경과**
```python
if holding_time >= 86400:
    return {
        'signal': 'EXIT',
        'reason': 'TIMEOUT_24H',
        'ai_check': False,
        'force': True
    }
```

---

### 3.7 strategy/trailing.py
**역할**: 트레일링 스톱 로직

**상태 관리**:
```python
{
    'symbol': 'DOGE/USDT',
    'entry_price': 100.0,
    'highest_price': 105.0,    # 진입 후 최고가
    'stop_price': 103.95,      # 현재 손절가 (highest * 0.99)
    'activated': True,          # 활성화 여부
    'activation_price': 100.5   # 활성화된 가격 (+0.5%)
}
```

**작동 예시**:
```
시간   현재가   최고가   손절가   상태
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
00:00  100.0   100.0    99.0    진입 (초기 손절)
00:03  100.5   100.5    99.5    트레일링 활성화!
00:05  101.0   101.0   100.0    고점 갱신
00:10  102.0   102.0   101.0    고점 갱신 (목표 도달!)
00:12  102.5   102.5   101.5    AI: HOLD → 계속
00:20  105.0   105.0   103.95   고점 갱신
00:30  104.0   105.0   103.95   하락 중 (고점 유지)
00:35  103.94  105.0   103.95   손절가 도달!
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
결과: +3.94% 수익으로 청산 ✅
```

**핵심 알고리즘**:
```python
def update(current_price):
    # 활성화 체크
    if not activated and current_price >= entry * 1.005:
        activated = True
        
    # 고점 갱신
    if activated and current_price > highest:
        highest = current_price
        stop_price = highest * 0.99
    
    # 손절 체크
    if current_price <= stop_price:
        return 'STOP'
```

---

### 3.8 ai/claude_client.py
**역할**: Claude API 통신 및 응답 처리

**API 설정**:
```python
Model: claude-3-sonnet-20240229
Max Tokens: 1024
Temperature: 0.3  # 낮을수록 일관성 ↑
Rate Limit: 분당 50회 (충분함)
```

**호출 타이밍**:
```
1. 진입 판단: 지표 3개 이상 충족 시
2. 목표 도달: +2% 도달 시
3. 정기 체크: 2시간마다
4. 긴급 상황: 급격한 시장 변화 시
→ 월 최대 약 60회 호출 예상
```

**프롬프트 구조** (ai/prompts.py):
```python
ENTRY_PROMPT = """
=== 현재 시장 데이터 ===
심볼: {symbol}
가격: ${price}
24h 변화: {change_24h}%

=== 기술적 지표 ===
RSI: {rsi} ({rsi_status})
MACD: {macd_status}
볼린저: {bb_position}
...

=== 시장 센티먼트 ===
최근 뉴스: {news_summary}
BTC 방향: {btc_trend}
Fear & Greed: {fear_greed}

=== 당신의 과거 성과 ===
최근 10거래 승률: {win_rate}%
평균 수익: {avg_profit}%
...

결정하세요: ENTER or WAIT
JSON 형식으로 응답하세요.
"""
```

**응답 파싱 및 검증**:
```python
def parse_response(raw_response):
    # JSON 추출
    json_str = extract_json(raw_response)
    parsed = json.loads(json_str)
    
    # 필수 필드 검증
    assert 'action' in parsed
    assert 'confidence' in parsed
    assert 0 <= parsed['confidence'] <= 1
    assert parsed['action'] in ['ENTER', 'EXIT', 'HOLD', 'WAIT']
    
    return parsed
```

**에러 처리**:
```python
try:
    response = await claude.call(prompt)
except RateLimitError:
    await asyncio.sleep(60)  # 1분 대기
    retry()
except JSONDecodeError:
    return {'action': 'WAIT', 'confidence': 0, 'error': 'parse_failed'}
except APIError as e:
    logger.error(f"Claude API 오류: {e}")
    # 폴백: 지표만으로 판단
    return fallback_decision(indicators)
```

---

### 3.9 ai/learner.py
**역할**: 거래 패턴 학습 및 파라미터 최적화

**학습 데이터 구조**:
```python
{
    'trade_id': 123,
    'entry_features': {
        'rsi': 42.5,
        'macd_histogram': 0.0015,
        'volume_ratio': 1.8,
        'hour_of_day': 14,
        'day_of_week': 3,
        'btc_correlation': 0.85
    },
    'exit_features': {
        'holding_minutes': 240,
        'max_profit': 3.2,
        'exit_reason': 'TRAILING_STOP'
    },
    'outcome': {
        'pnl_percent': 2.8,
        'result': 'WIN'
    }
}
```

**주간 분석 프로세스**:
```python
def weekly_analysis():
    # 1. 지난 7일 거래 조회
    trades = db.get_recent_trades(days=7)
    
    # 2. 승률 높은 패턴 찾기
    winning_patterns = analyze_winning_trades(trades)
    # 예: "RSI 30-40 + MACD 골든크로스 + 14시 진입" → 승률 80%
    
    # 3. 실패 패턴 찾기
    losing_patterns = analyze_losing_trades(trades)
    # 예: "RSI 60 이상 진입" → 승률 30%
    
    # 4. AI에게 종합 분석 요청
    ai_analysis = await claude.analyze_patterns({
        'winning_patterns': winning_patterns,
        'losing_patterns': losing_patterns,
        'performance_metrics': calculate_metrics(trades)
    })
    
    # 5. 파라미터 조정 제안
    suggestions = {
        'rsi_threshold': 35,  # 기존 30에서 상향
        'min_confidence': 0.72,  # 기존 0.70에서 상향
        'preferred_hours': [2, 3, 14, 15],  # 승률 높은 시간대
        'avoid_conditions': [
            'rsi > 65',
            'volume_ratio < 1.2'
        ]
    }
    
    # 6. 리포트 생성
    generate_learning_report(suggestions)
    
    return suggestions
```

**자동 적용 여부**:
```
현재: 제안만 생성, 수동 검토 후 config.py 수정
향후: A/B 테스트 후 자동 적용 가능
```

---

### 3.10 exchanges/bybit_live.py
**역할**: Bybit 실거래 인터페이스

**초기화**:
```python
def __init__(api_key, api_secret):
    self.exchange = ccxt.bybit({
        'apiKey': api_key,
        'secret': api_secret,
        'enableRateLimit': True,
        'options': {
            'defaultType': 'spot',  # 현물 거래
            'adjustForTimeDifference': True
        }
    })
    
    # 연결 테스트
    self.exchange.load_markets()
    balance = self.exchange.fetch_balance()
```

**주문 생성 (Market Order)**:
```python
def create_order(symbol, amount_krw):
    """
    입력: 'DOGE/USDT', 500000 (KRW)
    
    처리:
    1. KRW → USDT 환율 적용 (1300원 기준)
    2. amount_usdt = 500000 / 1300 = 384.6 USDT
    3. 현재가 조회: 0.3821 USDT
    4. 수량 계산: 384.6 / 0.3821 = 1006 DOGE
    5. Market Order 생성
    """
    
    # 1. USDT 변환
    usdt_amount = amount_krw / KRW_USD_RATE
    
    # 2. 현재가 조회
    ticker = self.exchange.fetch_ticker(symbol)
    current_price = ticker['last']
    
    # 3. 수량 계산
    quantity = usdt_amount / current_price
    
    # 4. 최소 주문 수량 체크
    market = self.exchange.market(symbol)
    if quantity < market['limits']['amount']['min']:
        raise InsufficientAmountError()
    
    # 5. 주문 생성
    order = self.exchange.create_market_buy_order(
        symbol=symbol,
        amount=quantity
    )
    
    # 6. 부분 체결 처리
    await asyncio.sleep(30)  # 30초 대기
    order = self.exchange.fetch_order(order['id'], symbol)
    
    if order['filled'] < quantity * 0.9:  # 90% 미만 체결
        # 미체결 부분 취소
        self.exchange.cancel_order(order['id'], symbol)
        quantity = order['filled']
    
    return {
        'order_id': order['id'],
        'filled': order['filled'],
        'average_price': order['average'],
        'fee': order['fee']
    }
```

**청산 (포지션 닫기)**:
```python
def close_position(symbol):
    """
    보유 수량 전량 Market Sell
    """
    balance = self.exchange.fetch_balance()
    base_currency = symbol.split('/')[0]  # 'DOGE'
    quantity = balance[base_currency]['free']
    
    if quantity == 0:
        raise NoPositionError()
    
    order = self.exchange.create_market_sell_order(
        symbol=symbol,
        amount=quantity
    )
    
    return {
        'order_id': order['id'],
        'quantity': order['filled'],
        'price': order['average'],
        'fee': order['fee']
    }
```

**잔고 조회**:
```python
def get_balance():
    balance = self.exchange.fetch_balance()
    
    return {
        'USDT': balance['USDT']['free'],
        'DOGE': balance['DOGE']['free'],
        'SOL': balance['SOL']['free'],
        'total_krw': calculate_total_krw(balance)
    }
```

---

### 3.11 exchanges/paper.py
**역할**: 모의투자 시뮬레이터

**가상 잔고 관리**:
```python
class PaperExchange:
    def __init__(self, initial_balance_krw):
        self.balance = {
            'USDT': initial_balance_krw / KRW_USD_RATE,
            'DOGE': 0.0,
            'SOL': 0.0
        }
        self.positions = {}  # 열린 포지션 추적
        self.trade_history = []
```

**모의 주문**:
```python
def create_order(symbol, amount_krw):
    """
    실제 API 호출 없이 내부 잔고만 조작
    """
    # 실시간 시세는 진짜 Bybit에서 조회
    ticker = real_exchange.fetch_ticker(symbol)
    price = ticker['last']
    
    # 가상 잔고 차감
    usdt_needed = amount_krw / KRW_USD_RATE
    if self.balance['USDT'] < usdt_needed:
        raise InsufficientBalanceError()
    
    self.balance['USDT'] -= usdt_needed
    
    # 수량 증가
    base = symbol.split('/')[0]
    quantity = usdt_needed / price
    self.balance[base] += quantity
    
    # 포지션 기록
    self.positions[symbol] = {
        'entry_price': price,
        'quantity': quantity,
        'entry_time': time.time()
    }
    
    return {'price': price, 'quantity': quantity}
```

**실거래와의 차이점**:
```
✅ 동일: 실시간 시세, 지표, AI 판단
❌ 다름: 실제 주문 체결 없음, 수수료 시뮬레이션
```

---

### 3.12 risk/manager.py
**역할**: 리스크 한도 모니터링 및 제어

**3가지 한도 체크**:

**1) 일일 손실 한도 (-5%)**
```python
def check_daily_loss(current_balance, today_start_balance):
    daily_pnl = (current_balance - today_start_balance) / today_start_balance
    
    if daily_pnl <= -0.05:
        logger.critical("🚨 일일 손실 -5% 도달!")
        close_all_positions()
        return {
            'action': 'STOP_TRADING',
            'resume_time': 'tomorrow 00:00'
        }
    
    return {'action': 'OK'}
```

**2) 월간 드로다운 (-10%)**
```python
def check_monthly_drawdown(current_balance, monthly_high):
    """
    이번 달 최고점 대비 하락률
    """
    if current_balance > monthly_high:
        monthly_high = current_balance  # 신고점 갱신
    
    drawdown = (current_balance - monthly_high) / monthly_high
    
    if drawdown <= -0.10:
        logger.critical("🚨 월간 드로다운 -10% 도달!")
        emergency_stop()
        return {
            'action': 'EMERGENCY_STOP',
            'resume_time': 'next month'
        }
    
    return {'action': 'OK'}
```

**3) 연속 손실 3회**
```python
def check_consecutive_losses(trade_result):
    if trade_result['pnl'] < 0:
        consecutive_losses += 1
    else:
        consecutive_losses = 0
    
    if consecutive_losses >= 3:
        logger.warning("⚠️ 연속 3회 손실")
        pause_trading(hours=24)
        return {
            'action': 'PAUSE_24H',
            'resume_time': time.time() + 86400
        }
    
    return {'action': 'OK'}
```

**통합 체크 함수**:
```python
def check_all_limits():
    """
    매 거래 전후 호출
    """
    results = []
    
    results.append(check_daily_loss())
    results.append(check_monthly_drawdown())
    results.append(check_consecutive_losses())
    
    # 하나라도 문제 있으면 중단
    for result in results:
        if result['action'] != 'OK':
            return result
    
    return {'action': 'OK'}
```

---

### 3.13 risk/position.py
**역할**: 포지션 크기 계산 (Kelly Criterion 선택 사용)

**기본 배분 방식**:
```python
def calculate_position_size(balance, symbol):
    """
    고정 배분: config.py의 POSITION_ALLOCATION 사용
    
    예: 1,000,000 KRW
    - DOGE: 50% = 500,000 KRW
    - SOL: 50% = 500,000 KRW
    """
    allocation = config.POSITION_ALLOCATION[symbol]
    return balance * allocation
```

**Kelly Criterion (선택)**:
```python
def kelly_position_size(balance, symbol, win_rate, avg_win, avg_loss):
    """
    Kelly 공식: f = (p*b - q) / b
    
    f = 베팅 비율
    p = 승률
    q = 패율 (1-p)
    b = 평균수익 / 평균손실
    
    예:
    승률 70%, 평균수익 +3.5%, 평균손실 -1%
    b = 3.5 / 1.0 = 3.5
    f = (0.7 * 3.5 - 0.3) / 3.5 = 0.61
    
    → 61% 배분 (너무 공격적!)
    → 1/4 Kelly 사용: 15.25%
    """
    p = win_rate
    q = 1 - win_rate
    b = avg_win / avg_loss
    
    kelly = (p * b - q) / b
    
    # 1/4 Kelly 적용 (리스크 완화)
    adjusted_kelly = kelly * 0.25
    
    # 최대 50% 제한
    final_fraction = min(adjusted_kelly, 0.5)
    
    return balance * final_fraction
```

**사용 시점**:
```
초기: 고정 배분 (50:50)
10거래 후: Kelly 활성화 (선택)
```

---

### 3.14 database/models.py
**역할**: SQLite 데이터베이스 스키마 정의

**테이블 구조**:

**1) trades 테이블**
```sql
CREATE TABLE trades (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    
    -- 기본 정보
    timestamp DATETIME NOT NULL,
    symbol TEXT NOT NULL,
    mode TEXT NOT NULL,  -- 'paper', 'live'
    
    -- 거래 정보
    entry_price REAL NOT NULL,
    exit_price REAL,
    quantity REAL NOT NULL,
    pnl_percent REAL,
    pnl_krw REAL,
    
    -- 진입 시점 지표
    rsi_entry REAL,
    macd_entry TEXT,  -- JSON
    bb_entry TEXT,    -- JSON
    volume_ratio REAL,
    
    -- AI 정보
    ai_confidence REAL,
    ai_reasoning TEXT,
    
    -- 청산 정보
    exit_reason TEXT,  -- 'STOP_LOSS', 'TRAILING_STOP', etc.
    exit_timestamp DATETIME,
    holding_minutes INTEGER,
    
    -- 수수료
    entry_fee REAL,
    exit_fee REAL,
    
    -- 상태
    status TEXT DEFAULT 'OPEN',  -- 'OPEN', 'CLOSED'
    
    INDEX idx_timestamp (timestamp),
    INDEX idx_symbol (symbol),
    INDEX idx_status (status)
);
```

**2) learning_data 테이블**
```sql
CREATE TABLE learning_data (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    trade_id INTEGER NOT NULL,
    timestamp DATETIME NOT NULL,
    
    -- 특징 데이터 (JSON)
    entry_features TEXT NOT NULL,
    exit_features TEXT,
    market_conditions TEXT,
    
    -- 결과
    outcome TEXT NOT NULL,  -- JSON
    
    -- 패턴
    patterns_detected TEXT,  -- JSON
    
    FOREIGN KEY (trade_id) REFERENCES trades(id)
);
```

**3) risk_events 테이블**
```sql
CREATE TABLE risk_events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp DATETIME NOT NULL,
    event_type TEXT NOT NULL,  -- 'DAILY_LIMIT', 'MONTHLY_DD', etc.
    details TEXT,  -- JSON
    action_taken TEXT
);
```

**4) config_history 테이블**
```sql
CREATE TABLE config_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp DATETIME NOT NULL,
    parameter_name TEXT NOT NULL,
    old_value REAL,
    new_value REAL,
    reason TEXT
);
```

---

### 3.15 monitoring/logger.py
**역할**: 모든 활동 로깅

**로그 레벨별 분리**:
```python
logs/
├── paper/
│   ├── 2025-01-15_trades.log      # 거래 기록
│   ├── 2025-01-15_decisions.log   # AI 판단
│   ├── 2025-01-15_errors.log      # 에러
│   └── 2025-01-15_debug.log       # 디버그
```

**로그 형식**:
```
[2025-01-15 14:32:15] [INFO] [ENTRY] DOGE/USDT @ 0.3821 | Amount: 500,000 KRW | AI: 0.75
[2025-01-15 14:32:16] [INFO] [ORDER] Bybit Order ID: 123456 | Filled: 1006 DOGE
[2025-01-15 16:45:22] [INFO] [EXIT] DOGE/USDT @ 0.3895 | PnL: +1.94% | Reason: TRAILING_STOP
[2025-01-15 18:00:00] [WARNING] [RISK] Daily Loss: -2.3% / -5.0%
[2025-01-15 20:15:33] [ERROR] [API] Bybit Connection Timeout - Retrying...
```

**로그 로테이션**:
```
- 일일 로그: 7일 보관
- 주간 요약: 4주 보관
- 월간 요약: 12개월 보관
```

---

### 3.16 monitoring/reporter.py
**역할**: 일일/주간/월간 리포트 생성

**일일 요약 (09:00, 21:00 확인용)**:
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 2025-01-15 일일 리포트 (21:00)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💼 계좌 현황:
  현재 잔고: 1,032,000 KRW
  일 수익률: +3.2%
  월 수익률: +8.7%

📈 오늘 거래:
  거래 횟수: 3회
  승률: 66.7% (2승 1패)
  평균 수익: +3.5%
  최대 수익: +4.2% (SOL)
  손실: -1.0% (DOGE)

🎯 심볼별:
  DOGE: 1회 (+4.2%)
  SOL: 2회 (+2.8%, -1.0%)

🤖 AI 통계:
  호출: 5회
  진입 승인: 3/4 (75%)
  평균 신뢰도: 0.73

⚠️  리스크 현황:
  일일 손실: +3.2% / -5.0% ✅
  월간 DD: -2.1% / -10.0% ✅
  연속 손실: 0회 ✅

📌 현재 포지션:
  없음

💡 특이사항:
  - 14:23 네트워크 재연결 (30초)
  - SOL 트레일링 스톱 작동 (+2.8%)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**주간 분석 (매주 월요일 자동)**:
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 주간 분석 (2025-01-13 ~ 2025-01-19)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📈 성과:
  총 거래: 15회
  승률: 66.7% (10승 5패)
  주간 수익률: +12.3%

🏆 성공 패턴:
  1. RSI 30-40 + MACD 골든크로스 + 14시 진입
     → 승률 80% (4/5)
  
  2. 볼린저 하단 터치 + 거래량 2배
     → 승률 75% (3/4)

❌ 실패 패턴:
  1. RSI > 60에서 진입
     → 승률 0% (0/3)
  
  2. 21-23시 진입
     → 승률 33% (1/3)

💡 AI 학습 제안:
  - RSI 임계값: 30 → 35
  - 최소 신뢰도: 0.70 → 0.72
  - 선호 시간대: [2, 3, 14, 15]
  - 회피 조건: RSI > 60, 거래량 < 1.5배

🔧 파라미터 조정 권장:
  config.MIN_AI_CONFIDENCE = 0.72
  선호 진입 시간: 02-04시, 14-16시
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

## 4. 데이터 흐름도

### 4.1 전체 시스템 흐름
```
[시작] run_paper.py / run_live.py
    ↓
[1] API 키 검증 (core/api_keys.py)
    ├─ BYBIT_API_KEY ✓
    ├─ CLAUDE_API_KEY ✓
    └─ 실패 시 즉시 종료
    ↓
[2] 엔진 초기화 (engine/paper_engine.py)
    ├─ Config 로드
    ├─ Exchange 연결
    ├─ Database 초기화
    ├─ Logger 설정
    └─ 모든 모듈 로드
    ↓
[3] 메인 루프 시작 (1분 주기)
    ↓
    ┌─────────────────────────────┐
    │  각 심볼(DOGE, SOL) 순회    │
    └─────────────────────────────┘
              ↓
    ┌─────────────────────────────┐
    │ [A] 실시간 데이터 수집       │
    │ data/fetcher.py             │
    │  - 현재가                   │
    │  - 200개 OHLCV 캔들         │
    │  - 호가창                   │
    └─────────────────────────────┘
              ↓
    ┌─────────────────────────────┐
    │ [B] 지표 계산                │
    │ indicators/calculator.py    │
    │  - RSI, MACD, BB, Fib      │
    │  - EMA, Volume Ratio       │
    └─────────────────────────────┘
              ↓
    ┌─────────────────────────────┐
    │ [C] 포지션 상태 확인         │
    └─────────────────────────────┘
              ↓
         포지션 있음?
         ├─ NO → [D] 진입 검토
         └─ YES → [E] 청산 검토
              ↓
    ┌─────────────────────────────┐
    │ [D] 진입 검토                │
    │ strategy/entry.py           │
    │  1. 지표 3개 이상 충족?     │
    │  2. AI 호출                 │
    │  3. ENTER + 신뢰도 ≥ 70%?  │
    └─────────────────────────────┘
              ↓ YES
    ┌─────────────────────────────┐
    │ [F] 주문 실행                │
    │ exchanges/bybit_live.py     │
    │  - Market Buy Order        │
    │  - 30초 대기 (부분 체결)   │
    │  - DB 저장                 │
    └─────────────────────────────┘
              ↓
    ┌─────────────────────────────┐
    │ [E] 청산 검토                │
    │ strategy/exit.py            │
    │  1. 손절 -1%?              │
    │  2. 트레일링 손절?          │
    │  3. 익절 +2%? (AI 호출)    │
    │  4. 2시간 경과? (AI 호출)  │
    │  5. 24시간 경과?           │
    └─────────────────────────────┘
              ↓ YES
    ┌─────────────────────────────┐
    │ [G] 청산 실행                │
    │  - Market Sell Order       │
    │  - PnL 계산 (수수료 포함)  │
    │  - DB 저장                 │
    └─────────────────────────────┘
              ↓
    ┌─────────────────────────────┐
    │ [H] 리스크 체크              │
    │ risk/manager.py             │
    │  - 일일 손실 -5%?          │
    │  - 월간 DD -10%?           │
    │  - 연속 손실 3회?          │
    └─────────────────────────────┘
              ↓ 문제 없음
    ┌─────────────────────────────┐
    │ [I] 로그 기록                │
    │ monitoring/logger.py        │
    └─────────────────────────────┘
              ↓
    ┌─────────────────────────────┐
    │ 60초 대기                   │
    └─────────────────────────────┘
              ↓
         (루프 반복)
```

### 4.2 AI 호출 흐름
```
[진입 신호 발생]
    ↓
[1] 프롬프트 데이터 준비
    ├─ 기술적 지표 (indicators)
    ├─ 시장 데이터 (price, volume)
    ├─ 뉴스 수집 (ai/news_api.py)
    ├─ 센티먼트 (ai/sentiment_api.py)
    └─ 과거 성과 (database)
    ↓
[2] 프롬프트 생성
    ai/prompts.py → ENTRY_PROMPT
    ↓
[3] Claude API 호출
    ai/claude_client.py
    ├─ Rate Limit 체크
    ├─ POST 요청
    └─ 응답 대기 (평균 2-3초)
    ↓
[4] 응답 파싱
    ai/analyzer.py
    ├─ JSON 추출
    ├─ 필수 필드 검증
    └─ 신뢰도 범위 체크
    ↓
[5] 의사결정
    ├─ ENTER + confidence ≥ 0.70 → 진입
    ├─ WAIT → 대기
    └─ 파싱 실패 → 폴백 로직
```

### 4.3 거래 데이터 흐름
```
[거래 발생]
    ↓
[진입 시]
database/trades.py → save_trade_entry()
    ├─ timestamp
    ├─ symbol
    ├─ entry_price
    ├─ quantity
    ├─ ai_confidence
    ├─ indicators (JSON)
    └─ status = 'OPEN'
    ↓
[trade_id 반환]
    ↓
[메모리에 포지션 추적]
engine.positions[symbol] = {
    'trade_id': 123,
    'entry_price': 0.3821,
    'quantity': 1006,
    'entry_time': timestamp
}
    ↓
[청산 시]
database/trades.py → update_trade_exit()
    ├─ exit_price
    ├─ pnl_percent
    ├─ pnl_krw
    ├─ exit_reason
    ├─ holding_minutes
    └─ status = 'CLOSED'
    ↓
[학습 데이터 저장]
database/learning.py → save_learning_data()
    ├─ trade_id (외래키)
    ├─ entry_features (JSON)
    ├─ exit_features (JSON)
    ├─ outcome (JSON)
    └─ patterns_detected (JSON)
```

---

## 5. API 통합 명세

### 5.1 Bybit API

**사용 엔드포인트**:
```
1. GET /v5/market/tickers - 현재가 조회
2. GET /v5/market/kline - OHLCV 캔들
3. GET /v5/market/orderbook - 호가창
4. POST /v5/order/create - 주문 생성
5. GET /v5/order/realtime - 주문 상태 조회
6. POST /v5/order/cancel - 주문 취소
7. GET /v5/account/wallet-balance - 잔고 조회
```

**Rate Limit**:
```
현물 거래: 초당 10회
우리 사용량: 분당 약 4회 (여유)
```

**에러 코드 처리**:
```python
10001: "파라미터 오류" → 주문 수량 재계산
10002: "잔고 부족" → InsufficientBalanceError
10003: "주문 실패" → 재시도 3회
10004: "인증 실패" → API 키 확인
20001: "Rate Limit" → 1초 대기 후 재시도
```

### 5.2 Claude API

**엔드포인트**:
```
POST https://api.anthropic.com/v1/messages
```

**요청 형식**:
```json
{
  "model": "claude-3-sonnet-20240229",
  "max_tokens": 1024,
  "temperature": 0.3,
  "messages": [
    {
      "role": "user",
      "content": "프롬프트 텍스트..."
    }
  ]
}
```

**응답 형식**:
```json
{
  "id": "msg_xxx",
  "type": "message",
  "role": "assistant",
  "content": [
    {
      "type": "text",
      "text": "{\"action\": \"ENTER\", \"confidence\": 0.75, ...}"
    }
  ],
  "stop_reason": "end_turn"
}
```

**에러 처리**:
```python
400: "잘못된 요청" → 프롬프트 검증
401: "인증 실패" → API 키 확인
429: "Rate Limit" → 60초 대기
500: "서버 오류" → 폴백 로직
```

**비용**:
```
입력: $0.003 / 1K tokens
출력: $0.015 / 1K tokens

예상 월 비용:
60회 호출 × 평균 2K tokens = $3-5
```

### 5.3 News API (선택)

**사용 가능한 소스**:
```
1. CoinGecko API (무료)
   - 암호화폐 뉴스
   - Rate Limit: 분당 50회
   
2. CryptoCompare (무료 티어)
   - 뉴스 + 소셜 데이터
   - Rate Limit: 시간당 100회

3. Alternative.me (무료)
   - Fear & Greed Index
   - 제한 없음
```

**데이터 구조**:
```python
# CoinGecko 뉴스
{
    'title': 'Dogecoin surges 15% after...',
    'description': '...',
    'url': 'https://...',
    'published_at': '2025-01-15T14:30:00Z',
    'sentiment': 'positive'  # 자체 분석
}

# Fear & Greed Index
{
    'value': 65,  # 0-100
    'classification': 'Greed',  # Extreme Fear / Fear / Neutral / Greed / Extreme Greed
    'timestamp': 1234567890
}
```

---

## 6. 거래 로직 상세

### 6.1 진입 조건 체크리스트

**1단계: 기술적 지표 (자동, 필수 4개)**
```python
checklist = {
    'rsi_ok': indicators['rsi']['value'] < 70,
    'macd_ok': indicators['macd']['golden_cross'] or 
               indicators['macd']['momentum'] == 'bullish',
    'bb_ok': indicators['bollinger']['lower_touch'],
    'fib_ok': indicators['fibonacci']['at_support']
}

# 최소 3개 충족
if sum(checklist.values()) < 3:
    return None  # 진입 불가
```

**2단계: 추가 확인 (자동, 선택)**
```python
additional = {
    'ema_trend': check_ema_alignment(),  # 20 > 50 > 200
    'volume': indicators['volume_ratio'] > 1.5,
    'stoch_rsi': indicators['stoch_rsi']['k'] > 20
}

# 추가 점수 계산
bonus_score = sum(additional.values()) * 10  # 0-30점
```

**3단계: AI 최종 판단 (필수)**
```python
ai_response = await claude.analyze({
    'indicators': indicators,
    'checklist': checklist,
    'additional': additional,
    'news': recent_news,
    'market': {
        'btc_trend': get_btc_trend(),
        'fear_greed': get_fear_greed_index()
    }
})

if ai_response['action'] == 'ENTER' and ai_response['confidence'] >= 0.70:
    return 'ENTER'
else:
    return None
```

### 6.2 청산 조건 우선순위

**우선순위 1: 초기 손절 (최우선)**
```python
if current_pnl <= -0.01:
    return {
        'action': 'EXIT',
        'reason': 'STOP_LOSS',
        'priority': 1,
        'ai_required': False
    }
```

**우선순위 2: 24시간 경과 (강제)**
```python
if holding_time >= 86400:
    return {
        'action': 'EXIT',
        'reason': 'TIMEOUT',
        'priority': 2,
        'ai_required': False
    }
```

**우선순위 3: 트레일링 손절**
```python
if trailing.is_active and current_price <= trailing.stop_price:
    return {
        'action': 'EXIT',
        'reason': 'TRAILING_STOP',
        'priority': 3,
        'highest': trailing.highest_price,
        'ai_required': False
    }
```

**우선순위 4: 목표가 도달 (AI 판단)**
```python
if current_pnl >= 0.02:
    ai_response = await claude.analyze_holding(...)
    
    if ai_response['action'] == 'EXIT':
        return {
            'action': 'EXIT',
            'reason': 'TARGET_EXIT',
            'priority': 4,
            'ai_confidence': ai_response['confidence']
        }
    # AI가 HOLD면 트레일링 계속
```

**우선순위 5: 정기 체크 (AI 판단)**
```python
if holding_time % 7200 < 60:  # 2시간 ± 1분
    ai_response = await claude.analyze_holding(...)
    
    if ai_response['action'] == 'EXIT':
        return {
            'action': 'EXIT',
            'reason': 'PERIODIC_EXIT',
            'priority': 5
        }
```

### 6.3 트레일링 스톱 상세 알고리즘

**초기 상태**:
```python
trailing = {
    'activated': False,
    'activation_price': entry_price * 1.005,  # +0.5%
    'highest_price': entry_price,
    'stop_price': entry_price * 0.99,  # -1%
    'stop_distance': 0.01  # 1%
}
```

**매 분마다 업데이트**:
```python
def update_trailing(current_price):
    # 1. 활성화 체크
    if not trailing['activated']:
        if current_price >= trailing['activation_price']:
            trailing['activated'] = True
            logger.info(f"🎯 트레일링 활성화! {current_price}")
    
    # 2. 고점 갱신 (활성화된 경우만)
    if trailing['activated']:
        if current_price > trailing['highest_price']:
            old_highest = trailing['highest_price']
            trailing['highest_price'] = current_price
            trailing['stop_price'] = current_price * (1 - trailing['stop_distance'])
            
            logger.info(
                f"📈 고점 갱신: {old_highest:.4f} → {current_price:.4f} "
                f"| 손절가: {trailing['stop_price']:.4f}"
            )
    
    # 3. 손절 체크
    if current_price <= trailing['stop_price']:
        final_pnl = (current_price - entry_price) / entry_price
        logger.info(
            f"🛑 트레일링 손절 발동! "
            f"고점: {trailing['highest_price']:.4f} "
            f"| 현재가: {current_price:.4f} "
            f"| 최종 수익: {final_pnl*100:+.2f}%"
        )
        return 'STOP'
    
    return 'CONTINUE'
```

**실제 작동 예시 (로그)**:
```
[14:32:15] 진입: DOGE @ 100.0 | 초기 손절: 99.0
[14:35:22] 가격: 100.5 | 🎯 트레일링 활성화!
[14:38:10] 가격: 101.2 | 📈 고점 갱신 | 손절: 100.19
[14:42:45] 가격: 102.0 | 📈 고점 갱신 | 손절: 100.98
[14:45:30] 가격: 102.8 | 📈 고점 갱신 | 손절: 101.77
[14:50:18] 가격: 105.0 | 📈 고점 갱신 | 손절: 103.95
[15:10:42] 가격: 104.2 | 고점 유지
[15:25:33] 가격: 103.94 | 🛑 트레일링 손절 발동!
[15:25:34] 청산 체결: 103.94 | 최종 수익: +3.94%
```

### 6.4 수수료 계산 로직

**Bybit 현물 수수료**:
```
Maker: 0.1%
Taker: 0.1%
Market Order = Taker
```

**실제 수익률 계산**:
```python
def calculate_real_pnl(entry_price, exit_price, quantity):
    # 매수 비용
    buy_cost = entry_price * quantity
    buy_fee = buy_cost * 0.001
    total_buy = buy_cost + buy_fee
    
    # 매도 수익
    sell_revenue = exit_price * quantity
    sell_fee = sell_revenue * 0.001
    total_sell = sell_revenue - sell_fee
    
    # 순수익
    net_profit = total_sell - total_buy
    
    # 실제 수익률
    real_pnl = net_profit / total_buy
    
    return {
        'gross_pnl': (exit_price - entry_price) / entry_price,
        'net_pnl': real_pnl,
        'total_fee': buy_fee + sell_fee,
        'fee_impact': -0.002  # 약 -0.2%
    }
```

**예시**:
```
진입: 100.0 USDT × 1000개 = 100,000 USDT
매수 수수료: 100,000 × 0.001 = 100 USDT
총 비용: 100,100 USDT

청산: 102.0 USDT × 1000개 = 102,000 USDT
매도 수수료: 102,000 × 0.001 = 102 USDT
총 수익: 101,898 USDT

순이익: 101,898 - 100,100 = 1,798 USDT
실제 수익률: 1,798 / 100,100 = 1.796%

명목 수익: +2.0%
실제 수익: +1.8% (수수료 -0.2%)
```

---

## 7. 리스크 관리 체계

### 7.1 3단계 안전장치

**Level 1: 개별 거래 (손절 -1%)**
```python
# 매 분마다 체크
for position in open_positions:
    current_pnl = calculate_pnl(position)
    
    if current_pnl <= -0.01:
        logger.warning(f"⚠️ {position['symbol']} 손절 발동 (-1%)")
        close_position(position['symbol'])
        
        # 통계 업데이트
        risk_manager.record_loss(current_pnl)
```

**Level 2: 일일 손실 (-5%)**
```python
# 매 거래 후 체크
def after_trade_check():
    today_start = get_today_start_balance()
    current = get_current_balance()
    
    daily_pnl = (current - today_start) / today_start
    
    if daily_pnl <= -0.05:
        logger.critical("🚨 일일 손실 한도 도달!")
        
        # 1. 모든 포지션 즉시 청산
        for position in open_positions:
            close_position(position['symbol'], reason='DAILY_LIMIT')
        
        # 2. 거래 중지
        trading_enabled = False
        resume_time = tomorrow_midnight()
        
        # 3. 알림 (향후 구현)
        send_alert("일일 손실 -5% 도달, 내일 재개")
        
        # 4. DB 기록
        db.record_risk_event({
            'type': 'DAILY_LIMIT',
            'loss': daily_pnl,
            'action': 'STOP_TRADING',
            'resume': resume_time
        })
```

**Level 3: 월간 드로다운 (-10%)**
```python
# 매 거래 후 체크
def check_monthly_drawdown():
    # 이번 달 최고점
    monthly_high = get_monthly_high_balance()
    current = get_current_balance()
    
    # 신고점 갱신
    if current > monthly_high:
        monthly_high = current
        save_monthly_high(monthly_high)
    
    # 드로다운 계산
    drawdown = (current - monthly_high) / monthly_high
    
    if drawdown <= -0.10:
        logger.critical("🚨🚨 월간 드로다운 -10% 도달!")
        
        # 1. 긴급 정지
        emergency_stop()
        
        # 2. 모든 포지션 청산
        force_close_all()
        
        # 3. 다음 달까지 중단
        trading_enabled = False
        resume_time = next_month_first_day()
        
        # 4. 긴급 알림
        send_critical_alert(
            "월간 드로다운 -10% 초과!\n"
            f"최고점: {monthly_high:,} KRW\n"
            f"현재: {current:,} KRW\n"
            f"손실: {drawdown*100:.2f}%"
        )
        
        # 5. DB 기록
        db.record_risk_event({
            'type': 'MONTHLY_DRAWDOWN',
            'drawdown': drawdown,
            'monthly_high': monthly_high,
            'action': 'EMERGENCY_STOP',
            'resume': resume_time
        })
```

### 7.2 연속 손실 제어

**추적 로직**:
```python
consecutive_losses = 0

def on_trade_close(pnl):
    global consecutive_losses
    
    if pnl < 0:
        consecutive_losses += 1
        logger.info(f"연속 손실: {consecutive_losses}회")
        
        if consecutive_losses >= 3:
            logger.warning("⚠️ 연속 3회 손실 발생!")
            
            # 1. 24시간 일시 중지
            pause_trading(hours=24)
            
            # 2. 원인 분석 트리거
            analyze_losing_streak()
            
            # 3. AI에게 피드백
            send_to_learner({
                'event': 'CONSECUTIVE_LOSSES',
                'trades': get_last_n_trades(3),
                'market_conditions': get_market_snapshot()
            })
    else:
        # 수익 시 초기화
        consecutive_losses = 0
```

**재개 조건**:
```python
def check_resume_after_pause():
    if time.time() >= pause_until:
        logger.info("✅ 24시간 경과, 거래 재개")
        
        # 1. 시장 상태 재확인
        market_ok = check_market_conditions()
        
        # 2. 시스템 자가진단
        system_ok = run_diagnostics()
        
        if market_ok and system_ok:
            consecutive_losses = 0
            trading_enabled = True
        else:
            logger.warning("시장/시스템 불안정, 1시간 추가 대기")
            pause_trading(hours=1)
```

### 7.3 리스크 대시보드 (실시간)

**표시 항목**:
```python
risk_status = {
    # 일일 한도
    'daily': {
        'current_pnl': +1.2,  # %
        'limit': -5.0,
        'remaining': 6.2,  # 5.0 - (-1.2)
        'status': 'OK'  # OK / WARNING / CRITICAL
    },
    
    # 월간 드로다운
    'monthly': {
        'current_dd': -3.5,  # %
        'limit': -10.0,
        'remaining': 6.5,
        'monthly_high': 1_150_000,
        'status': 'OK'
    },
    
    # 연속 손실
    'consecutive': {
        'current': 1,
        'limit': 3,
        'remaining': 2,
        'status': 'OK'
    },
    
    # 종합 상태
    'overall': 'GREEN'  # GREEN / YELLOW / RED
}
```

**경고 레벨**:
```
GREEN (안전):
  - 일일 손실 < -2%
  - 월간 DD < -5%
  - 연속 손실 0-1회

YELLOW (주의):
  - 일일 손실 -2% ~ -4%
  - 월간 DD -5% ~ -8%
  - 연속 손실 2회

RED (위험):
  - 일일 손실 -4% ~ -5%
  - 월간 DD -8% ~ -10%
  - 연속 손실 3회
```

---

## 8. AI 시스템 설계

### 8.1 프롬프트 엔지니어링

**진입 프롬프트 구조**:
```
Section 1: 시장 데이터 (300 tokens)
├─ 현재가, 24h 변화, 거래량
└─ 호가 불균형

Section 2: 기술적 지표 (400 tokens)
├─ RSI, MACD, Bollinger, Fibonacci
├─ 각 지표의 현재값 + 해석
└─ EMA 정렬, Volume Ratio, Stoch RSI

Section 3: 시장 맥락 (300 tokens)
├─ 최근 4시간 뉴스 요약
├─ BTC 방향성 및 상관관계
├─ Fear & Greed Index
└─ 시간대 (과거 성과 참고)

Section 4: 거래 이력 (200 tokens)
├─ 최근 10거래 승률
├─ 평균 수익/손실
├─ 최근 실패 패턴 (회피용)
└─ 유사 상황 과거 결과

Section 5: 지시사항 (100 tokens)
├─ 판단 기준 명시
├─ JSON 형식 요구
└─ 필수 필드 설명

총: ~1300 tokens (입력)
```

**보유 중 프롬프트 구조**:
```
Section 1: 포지션 정보 (200 tokens)
├─ 진입가, 현재가, P&L
├─ 보유 시간
└─ 최고/최저가

Section 2: 현재 시장 (300 tokens)
├─ 단기 트렌드 (5m, 15m, 1h)
├─ 거래량 추세
├─ RSI/MACD 현재 상태
└─ 호가 흐름

Section 3: 모멘텀 분석 (200 tokens)
├─ 매수/매도 압력
├─ 순유입/유출
└─ 변동성 변화

Section 4: 맥락 (200 tokens)
├─ 체크 타입 (TARGET_REACHED / PERIODIC)
├─ 최근 1시간 뉴스
└─ BTC 최근 움직임

Section 5: 리스크 파라미터 (100 tokens)
├─ 트레일링 상태
├─ 24시간 남은 시간
└─ 목표가까지 거리

총: ~1000 tokens
```

**학습 프롬프트 구조**:
```
Section 1: 주간 성과 (300 tokens)
├─ 총 거래, 승률, 수익
└─ 거래 목록 (간략)

Section 2: 승리 패턴 (400 tokens)
├─ 공통 요인 분석
├─ 최적 조건
└─ 성공 시간대

Section 3: 실패 패턴 (400 tokens)
├─ 손실 원인
├─ 오판 사례
└─ 회피 조건

Section 4: 시장 환경 (200 tokens)
├─ 전체 추세
├─ 변동성
└─ 뉴스 영향도

Section 5: 요청사항 (100 tokens)
├─ 인사이트 도출
├─ 파라미터 조정 제안
└─ JSON 형식

총: ~1400 tokens
```

### 8.2 응답 파싱 및 검증

**파싱 프로세스**:
```python
def parse_claude_response(raw_response):
    """
    Claude 응답 → 검증된 딕셔너리
    """
    try:
        # 1. 텍스트 추출
        if isinstance(raw_response, dict):
            content = raw_response['content'][0]['text']
        else:
            content = str(raw_response)
        
        # 2. JSON 부분 찾기
        json_start = content.find('{')
        json_end = content.rfind('}') + 1
        
        if json_start == -1 or json_end == 0:
            raise ValueError("JSON 블록을 찾을 수 없음")
        
        json_str = content[json_start:json_end]
        
        # 3. 파싱
        parsed = json.loads(json_str)
        
        # 4. 필수 필드 검증
        required = ['action', 'confidence', 'reasoning']
        missing = [f for f in required if f not in parsed]
        
        if missing:
            raise ValueError(f"필수 필드 누락: {missing}")
        
        # 5. 타입 검증
        parsed['confidence'] = float(parsed['confidence'])
        
        if not 0 <= parsed['confidence'] <= 1:
            raise ValueError(f"신뢰도 범위 오류: {parsed['confidence']}")
        
        valid_actions = ['ENTER', 'EXIT', 'HOLD', 'WAIT']
        if parsed['action'] not in valid_actions:
            raise ValueError(f"잘못된 action: {parsed['action']}")
        
        # 6. 성공
        return {
            'success': True,
            'data': parsed
        }
        
    except json.JSONDecodeError as e:
        logger.error(f"JSON 파싱 실패: {e}")
        return {
            'success': False,
            'error': 'JSON_PARSE_ERROR',
            'fallback': {
                'action': 'WAIT',
                'confidence': 0.0,
                'reasoning': 'AI 응답 파싱 실패'
            }
        }
    
    except Exception as e:
        logger.error(f"응답 처리 오류: {e}")
        return {
            'success': False,
            'error': str(e),
            'fallback': {
                'action': 'WAIT',
                'confidence': 0.0,
                'reasoning': f'오류: {e}'
            }
        }
```

**폴백 로직** (AI 실패 시):
```python
def fallback_decision(indicators):
    """
    AI 실패 시 지표만으로 판단
    """
    score = 0
    
    # RSI
    if indicators['rsi']['value'] < 30:
        score += 30
    elif indicators['rsi']['value'] < 50:
        score += 15
    
    # MACD
    if indicators['macd']['golden_cross']:
        score += 30
    elif indicators['macd']['momentum'] == 'bullish':
        score += 15
    
    # Bollinger
    if indicators['bollinger']['lower_touch']:
        score += 25
    
    # Fibonacci
    if indicators['fibonacci']['at_support']:
        score += 15
    
    # 60점 이상: 진입
    if score >= 60:
        return {
            'action': 'ENTER',
            'confidence': min(score / 100, 0.85),
            'reasoning': f'폴백 로직: {score}/100점',
            'fallback': True
        }
    
    return {
        'action': 'WAIT',
        'confidence': 0,
        'reasoning': f'폴백 로직: {score}/100점 (기준 미달)',
        'fallback': True
    }
```

### 8.3 AI 학습 사이클

**주간 학습 프로세스**:
```python
async def weekly_learning_cycle():
    """
    매주 월요일 00:00 자동 실행
    """
    logger.info("=== 주간 학습 사이클 시작 ===")
    
    # 1. 데이터 수집
    trades = db.get_trades_last_7_days()
    logger.info(f"분석 대상: {len(trades)}거래")
    
    # 2. 패턴 분석
    winning = analyze_winning_patterns(trades)
    losing = analyze_losing_patterns(trades)
    
    # 3. AI에게 종합 분석 요청
    learning_prompt = generate_learning_prompt(
        trades=trades,
        winning_patterns=winning,
        losing_patterns=losing
    )
    
    ai_analysis = await claude.call(learning_prompt)
    
    # 4. 제안사항 파싱
    suggestions = parse_learning_response(ai_analysis)
    
    # 5. 리포트 생성
    report = f"""
    ━━━━━━━━━━━━━━━━━━━━━━━
    🎓 주간 학습 리포트
    ━━━━━━━━━━━━━━━━━━━━━━━
    
    📊 성과:
      총 거래: {len(trades)}
      승률: {calculate_win_rate(trades):.1f}%
      
    🏆 TOP 3 성공 패턴:
    {format_patterns(winning[:3])}
    
    ❌ TOP 3 실패 패턴:
    {format_patterns(losing[:3])}
    
    💡 AI 제안:
    {format_suggestions(suggestions)}
    
    🔧 적용 방법:
      1. config.py 파일 열기
      2. 아래 값 수정:
         {generate_config_changes(suggestions)}
      3. 시스템 재시작
    
    ━━━━━━━━━━━━━━━━━━━━━━━
    """
    
    # 6. 저장
    save_learning_report(report)
    
    # 7. DB 기록
    db.save_learning_cycle({
        'timestamp': datetime.now(),
        'trades_analyzed': len(trades),
        'suggestions': suggestions
    })
    
    logger.info("=== 주간 학습 사이클 완료 ===")
    
    return suggestions
```

**자동 적용 vs 수동 적용**:
```
현재 설계: 수동 적용
- 제안만 생성
- 사용자가 검토 후 config.py 수정
- 안전성 우선

향후 개선 (Phase 2):
- A/B 테스트 모드
- 50% 기존, 50% 새 파라미터
- 2주 테스트 후 자동 적용
```

---

## 9. 예외 처리 전략

### 9.1 네트워크 오류

**재시도 로직**:
```python
import asyncio
from functools import wraps

def retry_on_network_error(max_retries=60, delay=1):
    """
    네트워크 오류 시 자동 재시도 데코레이터
    
    Args:
        max_retries: 최대 재시도 횟수 (기본 60회 = 1분)
        delay: 재시도 간격 (초)
    """
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return await func(*args, **kwargs)
                
                except (
                    ccxt.NetworkError,
                    ccxt.RequestTimeout,
                    aiohttp.ClientError
                ) as e:
                    logger.warning(
                        f"네트워크 오류 ({attempt+1}/{max_retries}): {e}"
                    )
                    
                    if attempt < max_retries - 1:
                        await asyncio.sleep(delay)
                        continue
                    else:
                        # 1분간 계속 실패
                        logger.critical("🚨 네트워크 1분 이상 불안정!")
                        
                        # 긴급 조치
                        emergency_network_failure()
                        
                        raise Exception(
                            "네트워크 연결 실패 (1분 초과). "
                            "시스템 안전 종료."
                        )
                
                except Exception as e:
                    # 네트워크가 아닌 다른 오류
                    logger.error(f"예상치 못한 오류: {e}")
                    raise
        
        return wrapper
    return decorator


def emergency_network_failure():
    """
    네트워크 장애 시 긴급 조치
    """
    logger.critical("=== 긴급 네트워크 장애 프로토콜 ===")
    
    # 1. 모든 열린 포지션 기록
    positions = get_open_positions()
    save_emergency_snapshot(positions)
    
    # 2. 청산 시도 (최선)
    for pos in positions:
        try:
            close_position_emergency(pos)
        except:
            logger.error(f"청산 실패: {pos['symbol']}")
    
    # 3. 사용자 알림
    send_critical_alert(
        "🚨 네트워크 장애 발생\n"
        f"열린 포지션: {len(positions)}개\n"
        "수동 확인 필요!"
    )
    
    # 4. 시스템 일시 중지
    pause_system(reason='NETWORK_FAILURE')
    
    logger.critical("시스템 안전 종료")
```

**적용 예시**:
```python
@retry_on_network_error(max_retries=60, delay=1)
async def fetch_market_data(symbol):
    return exchange.fetch_ticker(symbol)

@retry_on_network_error(max_retries=3, delay=5)
async def create_order(symbol, amount):
    return exchange.create_market_buy_order(symbol, amount)
```

### 9.2 API 오류

**Bybit API 오류 처리**:
```python
class BybitErrorHandler:
    """
    Bybit API 오류 분류 및 처리
    """
    
    def handle_error(self, error):
        """
        오류 코드별 처리
        """
        error_code = error.args[0] if error.args else None
        
        handlers = {
            10001: self._handle_parameter_error,
            10002: self._handle_insufficient_balance,
            10003: self._handle_order_failed,
            10004: self._handle_auth_failed,
            20001: self._handle_rate_limit,
            30001: self._handle_market_closed,
        }
        
        handler = handlers.get(error_code, self._handle_unknown_error)
        return handler(error)
    
    def _handle_parameter_error(self, error):
        """파라미터 오류 (10001)"""
        logger.error(f"파라미터 오류: {error}")
        
        # 주문 수량 재계산 필요
        return {
            'action': 'RECALCULATE',
            'retry': True
        }
    
    def _handle_insufficient_balance(self, error):
        """잔고 부족 (10002)"""
        logger.error("❌ 잔고 부족!")
        
        # 실제 잔고 재조회
        balance = exchange.fetch_balance()
        logger.info(f"실제 잔고: {balance}")
        
        return {
            'action': 'SKIP',
            'retry': False,
            'reason': 'INSUFFICIENT_BALANCE'
        }
    
    def _handle_order_failed(self, error):
        """주문 실패 (10003)"""
        logger.warning(f"주문 실패: {error}")
        
        # 3회까지 재시도
        return {
            'action': 'RETRY',
            'max_retries': 3,
            'delay': 2
        }
    
    def _handle_auth_failed(self, error):
        """인증 실패 (10004)"""
        logger.critical("🚨 API 키 인증 실패!")
        
        # 시스템 중단
        return {
            'action': 'STOP_SYSTEM',
            'reason': 'INVALID_API_KEY',
            'message': 'API 키를 확인하세요'
        }
    
    def _handle_rate_limit(self, error):
        """Rate Limit (20001)"""
        logger.warning("⏳ Rate Limit 도달, 대기 중...")
        
        return {
            'action': 'WAIT',
            'delay': 60,  # 1분 대기
            'retry': True
        }
    
    def _handle_market_closed(self, error):
        """시장 폐쇄 (30001)"""
        logger.info("시장 폐쇄 또는 거래 정지")
        
        return {
            'action': 'SKIP',
            'retry': False,
            'reason': 'MARKET_CLOSED'
        }
    
    def _handle_unknown_error(self, error):
        """알 수 없는 오류"""
        logger.error(f"알 수 없는 Bybit 오류: {error}")
        
        return {
            'action': 'LOG_AND_CONTINUE',
            'retry': False
        }
```

**Claude API 오류 처리**:
```python
class ClaudeErrorHandler:
    """
    Claude API 오류 분류 및 처리
    """
    
    async def call_with_error_handling(self, prompt):
        """
        오류 처리가 포함된 Claude 호출
        """
        try:
            response = await self.client.messages.create(
                model=self.model,
                max_tokens=self.max_tokens,
                temperature=self.temperature,
                messages=[{"role": "user", "content": prompt}]
            )
            
            return {
                'success': True,
                'data': response
            }
        
        except anthropic.RateLimitError as e:
            logger.warning("Claude Rate Limit 도달")
            
            # 60초 대기 후 재시도
            await asyncio.sleep(60)
            return await self.call_with_error_handling(prompt)
        
        except anthropic.APIError as e:
            logger.error(f"Claude API 오류: {e}")
            
            # 폴백: 지표만으로 판단
            return {
                'success': False,
                'error': 'API_ERROR',
                'fallback': True
            }
        
        except anthropic.AuthenticationError as e:
            logger.critical("🚨 Claude API 키 인증 실패!")
            
            # 시스템 중단
            raise Exception("Claude API 키가 유효하지 않습니다")
        
        except json.JSONDecodeError as e:
            logger.error(f"Claude 응답 파싱 실패: {e}")
            
            return {
                'success': False,
                'error': 'PARSE_ERROR',
                'fallback': True
            }
        
        except Exception as e:
            logger.error(f"예상치 못한 Claude 오류: {e}")
            
            return {
                'success': False,
                'error': str(e),
                'fallback': True
            }
```

### 9.3 데이터 이상 감지

**가격 스파이크 감지**:
```python
def detect_price_spike(current_price, recent_prices):
    """
    비정상적인 가격 급등락 감지
    
    Args:
        current_price: 현재가
        recent_prices: 최근 20개 가격
    
    Returns:
        bool: 스파이크 감지 시 True
    """
    if len(recent_prices) < 20:
        return False
    
    # 이동평균
    avg_price = np.mean(recent_prices)
    
    # 표준편차
    std_price = np.std(recent_prices)
    
    # 현재가가 평균 ± 3σ를 벗어나면 스파이크
    upper_bound = avg_price + (3 * std_price)
    lower_bound = avg_price - (3 * std_price)
    
    if current_price > upper_bound or current_price < lower_bound:
        deviation = abs(current_price - avg_price) / avg_price * 100
        
        logger.warning(
            f"⚠️ 가격 스파이크 감지! "
            f"현재: {current_price:.4f} "
            f"평균: {avg_price:.4f} "
            f"편차: {deviation:.2f}%"
        )
        
        return True
    
    return False


def handle_price_spike(symbol, current_price):
    """
    스파이크 발생 시 조치
    """
    logger.info("=== 가격 스파이크 대응 ===")
    
    # 1. 추가 데이터 수집 (확인)
    await asyncio.sleep(5)
    
    new_price = exchange.fetch_ticker(symbol)['last']
    
    # 2. 여전히 비정상이면
    if abs(new_price - current_price) / current_price > 0.05:
        logger.warning("가격 여전히 불안정, 거래 보류")
        
        # 해당 심볼 거래 일시 중지
        pause_symbol_trading(symbol, minutes=10)
        
        return 'SKIP'
    
    # 3. 정상화되면 계속
    logger.info("가격 정상화, 거래 진행")
    return 'CONTINUE'
```

**거래량 이상 감지**:
```python
def detect_volume_anomaly(current_volume, avg_volume):
    """
    비정상 거래량 감지
    """
    ratio = current_volume / avg_volume
    
    # 평균의 10배 이상 또는 0.1배 이하
    if ratio > 10:
        logger.warning(f"⚠️ 비정상 고거래량: {ratio:.1f}배")
        return 'HIGH_VOLUME'
    
    elif ratio < 0.1:
        logger.warning(f"⚠️ 비정상 저거래량: {ratio:.1f}배")
        return 'LOW_VOLUME'
    
    return 'NORMAL'
```

### 9.4 시스템 복구

**자동 복구 프로토콜**:
```python
class SystemRecovery:
    """
    시스템 장애 시 자동 복구
    """
    
    async def recover_from_crash(self):
        """
        비정상 종료 후 재시작 시 복구
        """
        logger.info("=== 시스템 복구 시작 ===")
        
        # 1. 마지막 상태 로드
        last_state = self.load_last_state()
        
        if not last_state:
            logger.info("복구할 상태 없음, 정상 시작")
            return
        
        # 2. 열린 포지션 확인
        saved_positions = last_state.get('positions', {})
        
        if not saved_positions:
            logger.info("열린 포지션 없음")
            return
        
        # 3. 실제 거래소 상태와 비교
        actual_positions = await self.get_actual_positions()
        
        # 4. 불일치 해결
        for symbol, saved_pos in saved_positions.items():
            if symbol not in actual_positions:
                logger.warning(
                    f"{symbol} 포지션이 이미 청산됨 "
                    "(시스템 다운 중 수동 청산?)"
                )
                
                # DB 업데이트
                self.close_position_in_db(
                    saved_pos['trade_id'],
                    reason='MANUAL_CLOSE_DURING_DOWNTIME'
                )
            
            else:
                logger.info(f"{symbol} 포지션 복구 완료")
                
                # 메모리에 복원
                self.restore_position(symbol, saved_pos)
        
        # 5. 리스크 상태 복구
        self.restore_risk_state(last_state)
        
        logger.info("=== 시스템 복구 완료 ===")
    
    def save_state_periodically(self):
        """
        5분마다 현재 상태 저장 (자동 백업)
        """
        state = {
            'timestamp': time.time(),
            'balance': get_current_balance(),
            'positions': get_open_positions(),
            'risk_state': get_risk_state(),
            'config': get_current_config()
        }
        
        with open('storage/system_state.json', 'w') as f:
            json.dump(state, f, indent=2)
```

**무한 루프 방지**:
```python
class LoopGuard:
    """
    무한 루프 및 반복 오류 방지
    """
    
    def __init__(self):
        self.error_counts = {}
        self.max_same_error = 5
        self.reset_interval = 3600  # 1시간마다 리셋
    
    def check_repeated_error(self, error_key):
        """
        동일 오류 반복 체크
        """
        now = time.time()
        
        if error_key not in self.error_counts:
            self.error_counts[error_key] = {
                'count': 1,
                'first_time': now,
                'last_time': now
            }
            return True
        
        error_info = self.error_counts[error_key]
        
        # 1시간 지나면 리셋
        if now - error_info['first_time'] > self.reset_interval:
            error_info['count'] = 1
            error_info['first_time'] = now
            return True
        
        # 카운트 증가
        error_info['count'] += 1
        error_info['last_time'] = now
        
        # 5회 이상 반복
        if error_info['count'] >= self.max_same_error:
            logger.critical(
                f"🚨 동일 오류 {self.max_same_error}회 반복: {error_key}"
            )
            
            # 긴급 중단
            raise Exception(
                f"동일 오류 반복으로 시스템 중단: {error_key}"
            )
        
        return True
```

---

## 10. 성능 및 모니터링

### 10.1 성과 지표

**Sharpe Ratio (샤프 비율)**:
```python
def calculate_sharpe_ratio(returns, risk_free_rate=0.03):
    """
    위험 대비 수익률 측정
    
    Args:
        returns: 거래별 수익률 리스트
        risk_free_rate: 무위험 수익률 (연 3%)
    
    Returns:
        float: Sharpe Ratio
    
    해석:
        > 2.0: 매우 우수
        1.0 - 2.0: 우수
        0.0 - 1.0: 보통
        < 0.0: 불량
    """
    if len(returns) < 2:
        return 0
    
    # 일일 수익률로 변환
    daily_returns = pd.Series(returns)
    
    # 연환산
    annual_return = daily_returns.mean() * 252
    annual_std = daily_returns.std() * np.sqrt(252)
    
    if annual_std == 0:
        return 0
    
    sharpe = (annual_return - risk_free_rate) / annual_std
    
    return sharpe
```

**Maximum Drawdown (최대 낙폭)**:
```python
def calculate_max_drawdown(balance_history):
    """
    최대 낙폭 계산
    
    Args:
        balance_history: [(timestamp, balance), ...]
    
    Returns:
        dict: {
            'max_dd': -0.15,  # -15%
            'peak': 1_200_000,
            'trough': 1_020_000,
            'duration_days': 12
        }
    """
    balances = [b[1] for b in balance_history]
    
    peak = balances[0]
    max_dd = 0
    peak_index = 0
    trough_index = 0
    
    for i, balance in enumerate(balances):
        # 신고점
        if balance > peak:
            peak = balance
            peak_index = i
        
        # 낙폭 계산
        drawdown = (balance - peak) / peak
        
        # 최대 낙폭 갱신
        if drawdown < max_dd:
            max_dd = drawdown
            trough_index = i
    
    # 기간 계산
    if trough_index > peak_index:
        duration = (
            balance_history[trough_index][0] - 
            balance_history[peak_index][0]
        ) / 86400  # 일수
    else:
        duration = 0
    
    return {
        'max_dd': max_dd,
        'peak': peak,
        'trough': balances[trough_index] if trough_index else peak,
        'duration_days': duration
    }
```

**Win Rate (승률)**:
```python
def calculate_win_rate(trades):
    """
    승률 및 관련 통계
    """
    total = len(trades)
    
    if total == 0:
        return None
    
    winners = [t for t in trades if t['pnl_percent'] > 0]
    losers = [t for t in trades if t['pnl_percent'] <= 0]
    
    win_rate = len(winners) / total * 100
    
    avg_win = np.mean([t['pnl_percent'] for t in winners]) if winners else 0
    avg_loss = np.mean([t['pnl_percent'] for t in losers]) if losers else 0
    
    # Profit Factor
    total_wins = sum(t['pnl_krw'] for t in winners)
    total_losses = abs(sum(t['pnl_krw'] for t in losers))
    
    profit_factor = total_wins / total_losses if total_losses > 0 else 0
    
    return {
        'total_trades': total,
        'win_rate': win_rate,
        'avg_win': avg_win,
        'avg_loss': avg_loss,
        'profit_factor': profit_factor,
        'best_trade': max(trades, key=lambda x: x['pnl_percent']),
        'worst_trade': min(trades, key=lambda x: x['pnl_percent'])
    }
```

### 10.2 실시간 대시보드 (터미널)

**표시 내용**:
```python
def display_dashboard():
    """
    터미널에 실시간 대시보드 출력
    """
    os.system('clear')  # 화면 클리어
    
    print("""
╔════════════════════════════════════════════════════════════╗
║         암호화폐 자동매매 시스템 - 실시간 대시보드           ║
╚════════════════════════════════════════════════════════════╝

📊 계좌 현황
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  초기 자본:  1,000,000 KRW
  현재 잔고:  1,035,420 KRW  (+3.54%)
  
  일일 수익:  +12,340 KRW  (+1.23%)
  월간 수익:  +35,420 KRW  (+3.54%)

💼 현재 포지션
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  DOGE/USDT
    진입가: 0.3821 USDT
    현재가: 0.3895 USDT  (+1.94%)
    수량:   1,006 DOGE
    평가액: 391.75 USDT
    보유:   2h 15m
    손절가: 0.3856 USDT (트레일링)
    상태:   🟢 수익 구간

📈 오늘 거래
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  거래 횟수: 3회
  승률: 66.7% (2승 1패)
  
  #1  SOL   +2.8%  TRAILING_STOP  ✅
  #2  DOGE  +4.2%  TARGET_EXIT    ✅
  #3  SOL   -1.0%  STOP_LOSS      ❌

⚠️  리스크 현황
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  일일 손실:  +1.23% / -5.00%    🟢 안전
  월간 DD:    -2.10% / -10.00%   🟢 안전
  연속 손실:  0회 / 3회           🟢 안전
  
  종합 상태: 🟢 GREEN

🤖 AI 통계 (오늘)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  호출 횟수:     5회
  진입 승인:     3/4  (75%)
  평균 신뢰도:   0.73
  마지막 호출:   14:32 (ENTER, 0.75)

📡 시스템 상태
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  Bybit 연결:    ✅ 정상
  Claude API:    ✅ 정상
  마지막 체크:   15:42:30
  다음 체크:     15:43:00 (30초 후)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  실행 시간: 8h 42m  |  모드: Paper Trading
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    """)
```

**업데이트 주기**: 1분마다 자동 갱신

### 10.3 로그 관리

**로그 레벨 구분**:
```python
# ERROR: 시스템 오류
logger.error("Bybit API 호출 실패: Connection timeout")

# WARNING: 주의 필요
logger.warning("일일 손실 -3.5% 도달 (한도: -5%)")

# INFO: 일반 정보
logger.info("[ENTRY] DOGE @ 0.3821 | AI: 0.75")

# DEBUG: 디버깅 정보
logger.debug(f"지표 계산 완료: RSI={rsi}, MACD={macd}")
```

**로그 파일 분리**:
```
logs/paper/2025-01-15_trades.log    # 거래만
logs/paper/2025-01-15_decisions.log # AI 판단만
logs/paper/2025-01-15_errors.log    # 오류만
logs/paper/2025-01-15_debug.log     # 전체
```

---

## 11. 배포 및 운영

### 11.1 실행 파일 구조

**run_paper.py**:
```python
"""
모의투자 실행 스크립트
"""
import asyncio
from core.api_keys import APIKeys
from core.config import Config
from engine import PaperEngine
from monitoring import setup_logging

async def main():
    print("=" * 60)
    print("🚀 Paper Trading 모드 시작")
    print("=" * 60)
    
    # 1. API 키 검증
    try:
        APIKeys.validate()
        print("✅ API 키 검증 완료")
    except ValueError as e:
        print(f"❌ {e}")
        return
    
    # 2. 설정 로드
    config = Config.load('paper')
    print(f"✅ 설정 로드 완료 (투자금: {config.INVESTMENT_AMOUNT:,} KRW)")
    
    # 3. 로깅 설정
    logger = setup_logging('paper', 'INFO')
    print("✅ 로깅 시스템 준비 완료")
    
    # 4. 엔진 초기화
    engine = PaperEngine(config, logger)
    await engine.initialize()
    print("✅ 엔진 초기화 완료")
    
    print("\n" + "=" * 60)
    print("📊 모의투자 시작! (Ctrl+C로 종료)")
    print("=" * 60 + "\n")
    
    # 5. 실행
    try:
        await engine.run()
    except KeyboardInterrupt:
        print("\n사용자 중단 요청")
    except Exception as e:
        logger.error(f"시스템 오류: {e}")
        raise
    finally:
        await engine.cleanup()
        print("시스템 종료 완료")

if __name__ == '__main__':
    asyncio.run(main())
```

**run_live.py**:
```python
"""
실거래 실행 스크립트
"""
import asyncio
from core.api_keys import APIKeys
from core.config import Config
from engine import LiveEngine
from monitoring import setup_logging

async def main():
    print("=" * 60)
    print("💰 Live Trading 모드")
    print("=" * 60)
    
    # API 키 검증
    try:
        APIKeys.validate()
    except ValueError as e:
        print(f"❌ {e}")
        return
    
    # 설정 로드
    config = Config.load('live')
    
    # ⚠️ 실거래 경고
    print("\n⚠️  경고: 실제 자금으로 거래합니다!")
    print(f"투자금: {config.INVESTMENT_AMOUNT:,} KRW")
    print(f"거래소: Bybit")
    print(f"대상: DOGE/USDT, SOL/USDT\n")
    
    confirm = input("계속하시겠습니까? (yes/no): ")
    
    if confirm.lower() != 'yes':
        print("실거래 취소됨")
        return
    
    # 로깅
    logger = setup_logging('live', 'INFO')
    
    # 엔진 초기화
    engine = LiveEngine(config, logger)
    await engine.initialize()
    
    print("\n" + "=" * 60)
    print("💰 실거래 시작!")
    print("=" * 60 + "\n")
    
    try:
        await engine.run()
    except KeyboardInterrupt:
        print("\n사용자 중단")
    finally:
        await engine.cleanup()

if __name__ == '__main__':
    asyncio.run(main())
```

**run_backtest.py**:
```python
"""
백테스트 실행 스크립트
"""
import asyncio
import argparse
from engine import BacktestEngine
from monitoring import setup_logging

async def main():
    # 명령줄 인자
    parser = argparse.ArgumentParser(description='백테스트 실행')
    parser.add_argument('--start', required=True, help='시작일 (YYYY-MM-DD)')
    parser.add_argument('--end', required=True, help='종료일 (YYYY-MM-DD)')
    parser.add_argument('--symbols', default='DOGE,SOL', help='심볼 (쉼표 구분)')
    
    args = parser.parse_args()
    
    print("=" * 60)
    print(f"📊 백테스트: {args.start} ~ {args.end}")
    print("=" * 60)
    
    # 로깅
    logger = setup_logging('backtest', 'INFO')
    
    # 엔진
    engine = BacktestEngine(
        start_date=args.start,
        end_date=args.end,
        symbols=args.symbols.split(','),
        logger=logger
    )
    
    await engine.initialize()
    await engine.run()
    
    # 결과 리포트
    engine.generate_final_report()

if __name__ == '__main__':
    asyncio.run(main())
```

### 11.2 requirements.txt

```txt
# 거래소 API
ccxt==4.2.25

# AI
anthropic==0.18.1

# 데이터 처리
pandas==2.2.0
numpy==1.26.3
pandas-ta==0.3.14b

# 비동기
aiohttp==3.9.3
asyncio==3.4.3

# 환경변수
python-dotenv==1.0.1

# 로깅
colorlog==6.8.0

# 기타
python-dateutil==2.8.2
pytz==2024.1
```

### 11.3 .gitignore

```
# API 키 (절대 커밋 금지!)
.env

# 데이터베이스
storage/*.db
storage/*.db-journal

# 로그
logs/
*.log

# 캐시
storage/cache/
__pycache__/
*.pyc
*.pyo
*.pyd

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# 백테스트 데이터 (용량 큼)
storage/historical/*.csv
```

### 11.4 README.md 구조

```markdown
# 암호화폐 자동매매 시스템

AI 기반 암호화폐 현물 자동매매 시스템

## 주요 기능
- 24시간 자동 매매
- Claude AI 의사결정
- 트레일링 스톱
- 리스크 관리
- 자동 학습

## 빠른 시작

### 1. 설치
```bash
git clone https://github.com/your-repo/crypto-trading-bot.git
cd crypto-trading-bot
pip install -r requirements.txt
```

### 2. API 키 설정
```bash
cp .env.example .env
nano .env  # API 키 입력
```

### 3. 실행
```bash
# 모의투자
python run_paper.py

# 실거래
python run_live.py

# 백테스트
python run_backtest.py --start 2024-01-01 --end 2024-12-31
```

## 설정

`core/config.py` 파일에서 주요 설정 변경:

```python
INVESTMENT_AMOUNT = 1_000_000  # 투자금 (KRW)
TAKE_PROFIT = 0.02             # 익절 +2%
STOP_LOSS = -0.01              # 손절 -1%
```

## 안전 장치
- 일일 손실 한도: -5%
- 월간 드로다운: -10%
- 연속 3회 손실: 24시간 중단

## 문서
- [전체 기획서](docs/기획서v3.md)
- [API 문서](docs/API.md)
- [FAQ](docs/FAQ.md)

## 주의사항
⚠️ 암호화폐 거래는 고위험 투자입니다.
⚠️ 실거래 전 충분한 모의투자 테스트를 권장합니다.
```

### 11.5 24시간 운영 방법

**옵션 1: VPS (추천)**
```bash
# Ubuntu VPS 설정
sudo apt update
sudo apt install python3 python3-pip tmux

# 프로젝트 설치
git clone ...
cd crypto-trading-bot
pip3 install -r requirements.txt

# tmux로 백그라운드 실행
tmux new -s trading
python3 run_live.py

# tmux 나가기: Ctrl+B, D
# tmux 다시 접속: tmux attach -t trading
```

**옵션 2: systemd (Linux)**
```bash
# /etc/systemd/system/crypto-bot.service
[Unit]
Description=Crypto Trading Bot
After=network.target

[Service]
Type=simple
User=your-user
WorkingDirectory=/home/your-user/crypto-trading-bot
ExecStart=/usr/bin/python3 /home/your-user/crypto-trading-bot/run_live.py
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target

# 활성화
sudo systemctl enable crypto-bot
sudo systemctl start crypto-bot

# 상태 확인
sudo systemctl status crypto-bot

# 로그 확인
sudo journalctl -u crypto-bot -f
```

**옵션 3: Docker**
```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["python", "run_live.py"]
```

```bash
# 빌드
docker build -t crypto-bot .

# 실행
docker run -d \
  --name crypto-bot \
  --restart unless-stopped \
  -v $(pwd)/.env:/app/.env \
  -v $(pwd)/logs:/app/logs \
  -v $(pwd)/storage:/app/storage \
  crypto-bot

# 로그 확인
docker logs -f crypto-bot
```

### 11.6 모니터링 방법

**방법 1: 로그 파일 직접 확인**
```bash
# 실시간 로그 모니터링
tail -f logs/live/2025-01-15_trades.log

# 오늘 거래 요약
grep "EXIT" logs/live/$(date +%Y-%m-%d)_trades.log

# 오늘 수익률
grep "PnL:" logs/live/$(date +%Y-%m-%d)_trades.log | awk '{sum+=$5; count++} END {print "평균:", sum/count "%"}'
```

**방법 2: 일일 리포트 확인**
```bash
cat logs/daily_summary/$(date +%Y-%m-%d).txt
```

**방법 3: 데이터베이스 쿼리**
```bash
sqlite3 storage/trades.db

# 오늘 거래
SELECT symbol, entry_price, exit_price, pnl_percent, exit_reason 
FROM trades 
WHERE date(timestamp) = date('now') 
ORDER BY timestamp DESC;

# 월간 통계
SELECT 
  COUNT(*) as total,
  ROUND(AVG(CASE WHEN pnl_percent > 0 THEN 1.0 ELSE 0.0 END) * 100, 1) as win_rate,
  ROUND(AVG(pnl_percent), 2) as avg_pnl
FROM trades
WHERE strftime('%Y-%m', timestamp) = strftime('%Y-%m', 'now');
```

**방법 4: 웹 대시보드 (향후 추가)**
```python
# 추후 구현 예정
# dashboard/app.py (Flask)
# http://localhost:5000 에서 실시간 모니터링
```

---

## 12. 추가 기능 및 향후 개선

### 12.1 Phase 1 완료 항목 (현재 기획서)
- ✅ 기본 거래 시스템
- ✅ AI 진입/청산 판단
- ✅ 트레일링 스톱
- ✅ 리스크 관리 (3단계)
- ✅ 데이터베이스 기록
- ✅ 주간 학습 분석
- ✅ 로그 시스템
- ✅ Paper/Live/Backtest 모드

### 12.2 Phase 2 개선 계획
```
1. 알림 시스템
   - Telegram Bot
   - Discord Webhook
   - 이메일 알림

2. 웹 대시보드
   - Flask 기반 실시간 대시보드
   - 차트 시각화 (Plotly)
   - 모바일 반응형

3. 고급 AI 기능
   - 뉴스 자동 수집 및 분석
   - 소셜 센티먼트 분석
   - 다중 모델 앙상블 (Claude + GPT-4)

4. 전략 다양화
   - 다중 시간프레임 전략
   - 변동성 기반 포지션 조절
   - 상관관계 기반 포트폴리오

5. 성능 최적화
   - 병렬 처리 (다중 심볼 동시 분석)
   - Redis 캐싱
   - PostgreSQL 마이그레이션
```

### 12.3 선택적 기능

**동적 포지션 조절**:
```python
# 승률에 따라 포지션 크기 자동 조정
if win_rate > 0.70:
    position_size *= 1.2  # 20% 증가
elif win_rate < 0.50:
    position_size *= 0.8  # 20% 감소
```

**시간대별 전략**:
```python
# 시간대별 다른 파라미터
if 2 <= hour <= 4:  # 아시아 시간대
    MIN_CONFIDENCE = 0.65
elif 14 <= hour <= 16:  # 미국 오전
    MIN_CONFIDENCE = 0.70
else:
    MIN_CONFIDENCE = 0.75
```

**변동성 기반 손절**:
```python
# 변동성 높을 때 손절 폭 확대
atr = calculate_atr(ohlcv)
dynamic_stop_loss = -0.01 * (1 + atr * 2)
```

---

## 13. 테스트 계획

### 13.1 단위 테스트

**tests/test_indicators.py**:
```python
import unittest
from indicators import calculate_rsi, calculate_macd

class TestIndicators(unittest.TestCase):
    def test_rsi_calculation(self):
        """RSI 계산 정확도 테스트"""
        prices = [100, 102, 101, 103, 105, 104, 106, 108]
        rsi = calculate_rsi(prices, period=14)
        
        self.assertIsInstance(rsi, dict)
        self.assertIn('value', rsi)
        self.assertTrue(0 <= rsi['value'] <= 100)
    
    def test_macd_golden_cross(self):
        """MACD 골든크로스 감지 테스트"""
        # 상승 추세 데이터
        prices = list(range(100, 120))
        macd = calculate_macd(prices)
        
        # 골든크로스 발생 여부
        self.assertIn('golden_cross', macd)
```

**tests/test_strategy.py**:
```python
class TestEntryStrategy(unittest.TestCase):
    def test_entry_conditions(self):
        """진입 조건 체크"""
        indicators = {
            'rsi': {'value': 35},
            'macd': {'golden_cross': True},
            'bollinger': {'lower_touch': True},
            'fibonacci': {'at_support': True}
        }
        
        strategy = EntryStrategy(None, None)
        signal_count = strategy.count_signals(indicators)
        
        self.assertEqual(signal_count, 4)
```

**tests/test_risk.py**:
```python
class TestRiskManager(unittest.TestCase):
    def test_daily_loss_limit(self):
        """일일 손실 한도 테스트"""
        risk = RiskManager(config)
        
        # -5% 손실 시뮬레이션
        result = risk.check_daily_loss(950_000, 1_000_000)
        
        self.assertEqual(result['action'], 'STOP_TRADING')
```

### 13.2 통합 테스트

**시나리오 1: 정상 거래 흐름**
```
1. 시스템 시작
2. 데이터 수집
3. 진입 신호 발생
4. AI 승인
5. 주문 체결
6. 트레일링 작동
7. 청산 체결
8. DB 저장
```

**시나리오 2: 손절 발동**
```
1. 진입
2. 가격 -1% 하락
3. 자동 손절
4. 리스크 상태 업데이트
```

**시나리오 3: 네트워크 장애**
```
1. API 호출 실패
2. 재시도 60회
3. 긴급 프로토콜 발동
4. 포지션 스냅샷 저장
```

### 13.3 백테스트 검증

**목표**:
- 최소 6개월 이상 과거 데이터
- 최소 100회 이상 거래
- 승률 60% 이상
- Sharpe Ratio 1.0 이상
- 최대 낙폭 -15% 이내

**실행**:
```bash
python run_backtest.py --start 2024-01-01 --end 2024-12-31
```

**검증 항목**:
```
✅ 진입 조건이 실제로 작동하는가?
✅ 트레일링 스톱이 수익을 보호하는가?
✅ 손절이 제때 발동하는가?
✅ 수수료 계산이 정확한가?
✅ 리스크 한도가 준수되는가?
```

---

## 14. FAQ (자주 묻는 질문)

### Q1: 얼마의 자금이 필요한가요?
**A:** 최소 100만원 권장. config.py에서 자유롭게 설정 가능하지만, 너무 적으면 Bybit 최소 주문 금액에 제한될 수 있습니다.

### Q2: 수익률은 얼마나 되나요?
**A:** 목표 월 3-5%. 실제 수익률은 시장 상황에 따라 다르며, 손실 가능성도 있습니다.

### Q3: 24시간 컴퓨터를 켜둬야 하나요?
**A:** VPS(가상 서버) 사용을 권장합니다. 월 5-10달러 수준의 저렴한 클라우드 서버로 충분합니다.

### Q4: AI 비용이 얼마나 드나요?
**A:** Claude API는 월 약 5-10달러 예상. 투자 대비 매우 저렴합니다.

### Q5: 실거래 전에 무엇을 해야 하나요?
**A:** 
1. Paper Trading으로 최소 1-2주 테스트
2. 백테스트로 전략 검증
3. 소액(10만원)으로 Live Trading 테스트
4. 문제 없으면 본격 투자

### Q6: 손실이 발생하면 어떻게 되나요?
**A:** 3단계 안전장치가 작동:
- 개별 거래: -1% 손절
- 일일: -5% 도달 시 당일 중단
- 월간: -10% 도달 시 긴급 정지

### Q7: AI가 잘못 판단하면?
**A:** 폴백 로직이 작동하여 기술적 지표만으로 판단. 또한 주간 학습을 통해 점차 개선됩니다.

### Q8: 다른 코인도 추가할 수 있나요?
**A:** 네, `core/constants.py`의 SYMBOLS 리스트에 추가하면 됩니다. 단, 거래량이 충분한 메이저 코인 권장.

### Q9: 레버리지는 사용하나요?
**A:** 아니요. 현물 거래만 사용하여 리스크를 최소화합니다.

### Q10: 시스템이 다운되면?
**A:** 
- 5분마다 자동 상태 백업
- 재시작 시 자동 복구
- 열린 포지션 확인 및 복원

---

## 15. 체크리스트

### 개발 전 준비
- [ ] Python 3.11+ 설치
- [ ] Bybit 계정 생성
- [ ] Bybit API 키 발급 (현물 거래 권한)
- [ ] Claude API 키 발급 (Anthropic)
- [ ] Git 설치 (버전 관리)

### 개발 단계
- [ ] 프로젝트 디렉토리 구조 생성
- [ ] requirements.txt 의존성 설치
- [ ] .env 파일 설정
- [ ] core/ 모듈 구현
- [ ] data/ 모듈 구현
- [ ] indicators/ 모듈 구현
- [ ] strategy/ 모듈 구현
- [ ] ai/ 모듈 구현
- [ ] exchanges/ 모듈 구현
- [ ] risk/ 모듈 구현
- [ ] database/ 모듈 구현
- [ ] engine/ 모듈 구현
- [ ] monitoring/ 모듈 구현
- [ ] utils/ 모듈 구현

### 테스트 단계
- [ ] 단위 테스트 작성 및 통과
- [ ] 통합 테스트 통과
- [ ] 백테스트 실행 (6개월)
- [ ] Paper Trading 실행 (1주일)
- [ ] 성능 지표 확인 (Sharpe, DD)

### 배포 단계
- [ ] VPS 서버 준비
- [ ] 프로젝트 배포
- [ ] systemd 또는 tmux 설정
- [ ] 로그 모니터링 확인
- [ ] 소액 Live Trading 테스트 (1주일)
- [ ] 본격 Live Trading 시작

### 운영 단계
- [ ] 일일 리포트 확인 (09:00, 21:00)
- [ ] 주간 학습 리포트 검토 (월요일)
- [ ] 파라미터 조정 (필요시)
- [ ] 월간 성과 분석
- [ ] 시스템 업데이트 (보안, 버그 수정)

---

## 16. 최종 정리

### 시스템 핵심 요약

**거래 방식**:
- 현물 거래 (레버리지 없음)
- Market Order (즉시 체결)
- 2개 심볼: DOGE/USDT, SOL/USDT
- 50:50 배분

**손익 구조**:
- 목표 익절: +2%
- 초기 손절: -1%
- 트레일링: +0.5% 활성화, 고점 -1%
- 손익비: 2:1

**리스크 관리**:
- 일일 한도: -5%
- 월간 한도: -10%
- 연속 손실: 3회 → 24시간 중단

**AI 역할**:
- 진입: 필수 (신뢰도 70%+)
- 청산: 목표 도달 시, 2시간마다
- 학습: 주 1회 패턴 분석

**실행 주기**:
- 메인 루프: 1분
- AI 호출: 월 약 60회
- 비용: 월 $5-10

### 성공 요인
1. **보수적 리스크 관리**: 손실 제한이 명확함
2. **AI + 지표 조합**: 오판 최소화
3. **트레일링 스톱**: 수익 극대화
4. **지속적 학습**: 전략 자동 개선
5. **완전 자동화**: 감정 개입 없음

### 주의사항
⚠️ 암호화폐는 고위험 투자입니다.  
⚠️ 과거 성과가 미래를 보장하지 않습니다.  
⚠️ 투자 손실 가능성을 인지하세요.  
⚠️ 여유 자금으로만 투자하세요.

---

## 📞 지원 및 문의

- **문서**: 이 기획서 참조
- **이슈**: GitHub Issues
- **업데이트**: GitHub Releases

---

**문서 버전**: v3.0  
**작성일**: 2025-01-15  
**최종 수정**: 2025-01-15  

---

# 🎉 기획서 완료!

이 문서를 기반으로 개발을 시작하세요. 모든 모듈의 역할, 데이터 흐름, 예외 처리가 명시되어 있어 다른 개발자도 동일한 시스템을 구축할 수 있습니다.

**다음 단계**: 실제 코드 구현 시작! 🚀
