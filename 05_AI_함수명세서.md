# 05_AI ëª¨ë“ˆ ì™„ë²½ í•¨ìˆ˜ ëª…ì„¸ì„œ

> **ëª©í‘œ**: ì´ ë¬¸ì„œë§Œìœ¼ë¡œ ëˆ„êµ¬ë‚˜ ë™ì¼í•œ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆë‹¤

---

## ğŸ“‹ ëª©ì°¨
1. [ai/claude_client.py](#aiclaudeclientpy)
2. [ai/analyzer.py](#aianalyzerpy)
3. [ai/prompts.py](#aiprompspy)
4. [ai/learner.py](#ailearnerpy)
5. [ai/news_api.py (ì„ íƒ)](#ainewsapipy)
6. [ì „ì²´ ì˜ì¡´ì„± ê·¸ë˜í”„](#ì „ì²´-ì˜ì¡´ì„±-ê·¸ë˜í”„)

---

## ğŸ“ ai/claude_client.py

### íŒŒì¼ ì „ì²´ êµ¬ì¡°
```python
import anthropic
import asyncio
from typing import Dict, Optional
from core.api_keys import APIKeys
from core.exceptions import AIResponseError
from .analyzer import ResponseAnalyzer

class ClaudeClient:
    def __init__(self): ...
    
    async def analyze_entry(
        self,
        symbol: str,
        price: float,
        indicators: Dict,
        market_context: Dict
    ) -> Dict: ...
    
    async def analyze_holding(
        self,
        symbol: str,
        entry_price: float,
        current_price: float,
        current_pnl: float,
        holding_time: float,
        indicators: Dict,
        check_type: str
    ) -> Dict: ...
    
    async def _call_api(self, prompt: str) -> Dict: ...
```

---

### ğŸ“Œ í´ë˜ìŠ¤: ClaudeClient

#### ëª©ì 
Claude API í†µì‹  ë° ì‘ë‹µ ì²˜ë¦¬

---

### ğŸ“Œ í•¨ìˆ˜: ClaudeClient.__init__()

```python
def __init__(self):
```

#### ì—­í• 
Claude í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”

#### ì‚¬ìš©í•˜ëŠ” ëª¨ë“ˆ/í•¨ìˆ˜
- `APIKeys.get_claude_config()` - API í‚¤ ë° ì„¤ì •
- `anthropic.Anthropic()` - Claude í´ë¼ì´ì–¸íŠ¸
- `ResponseAnalyzer()` - ì‘ë‹µ íŒŒì‹±ê¸°

#### ì´ˆê¸°í™” ë‚´ìš©
```python
config = APIKeys.get_claude_config()
self.client = anthropic.Anthropic(api_key=config['api_key'])
self.model = config['model']
self.max_tokens = config['max_tokens']
self.temperature = config['temperature']
self.analyzer = ResponseAnalyzer()
```

#### í˜¸ì¶œë˜ëŠ” ê³³
```python
# engine/base_engine.py __init__()
from ai import ClaudeClient

self.claude = ClaudeClient()
```

#### êµ¬í˜„ ì½”ë“œ
```python
def __init__(self):
    """Claude í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”"""
    config = APIKeys.get_claude_config()
    
    self.client = anthropic.Anthropic(
        api_key=config['api_key']
    )
    self.model = config['model']
    self.max_tokens = config['max_tokens']
    self.temperature = config['temperature']
    
    self.analyzer = ResponseAnalyzer()
```

---

### ğŸ“Œ í•¨ìˆ˜: ClaudeClient.analyze_entry(symbol, price, indicators, market_context)

```python
async def analyze_entry(
    self,
    symbol: str,
    price: float,
    indicators: Dict,
    market_context: Dict
) -> Dict:
```

#### ì—­í• 
ì§„ì… íŒë‹¨ ìš”ì²­

#### ì¸ì
- `symbol: str` - 'DOGE/USDT'
- `price: float` - í˜„ì¬ê°€
- `indicators: Dict` - calculator.calculate_all() ê²°ê³¼
- `market_context: Dict` - ì¶”ê°€ ì‹œì¥ ì •ë³´

#### ì‚¬ìš©í•˜ëŠ” ëª¨ë“ˆ/í•¨ìˆ˜
1. `prompts.generate_entry_prompt(...)` - í”„ë¡¬í”„íŠ¸ ìƒì„±
2. `self._call_api(prompt)` - API í˜¸ì¶œ
3. `self.analyzer.parse_response(raw)` - ì‘ë‹µ íŒŒì‹±

#### í˜¸ì¶œë˜ëŠ” ê³³
```python
# strategy/entry.py check_entry_signal()
ai_response = await self.claude.analyze_entry(
    symbol='DOGE/USDT',
    price=0.3821,
    indicators=indicators,
    market_context={...}
)
```

#### ë°˜í™˜ê°’
```python
Dict:
    'action': str = 'ENTER' | 'WAIT'
    'confidence': float = 0.75  # 0-1
    'reasoning': str = "MACD golden cross with strong volume..."
    'key_factors': List[str] = ['macd', 'volume', 'rsi']
    'risk_level': str = 'MEDIUM'  # LOW, MEDIUM, HIGH
```

#### êµ¬í˜„ ì½”ë“œ
```python
async def analyze_entry(
    self,
    symbol: str,
    price: float,
    indicators: Dict,
    market_context: Dict
) -> Dict:
    """
    ì§„ì… íŒë‹¨
    
    Returns:
        {
            'action': 'ENTER' or 'WAIT',
            'confidence': 0.75,
            'reasoning': '...',
            'key_factors': ['macd', 'volume']
        }
    """
    from .prompts import generate_entry_prompt
    
    # í”„ë¡¬í”„íŠ¸ ìƒì„±
    prompt = generate_entry_prompt(
        symbol=symbol,
        price=price,
        indicators=indicators,
        market_context=market_context
    )
    
    # API í˜¸ì¶œ
    raw_response = await self._call_api(prompt)
    
    # ì‘ë‹µ íŒŒì‹±
    parsed = self.analyzer.parse_response(raw_response)
    
    return parsed
```

---

### ğŸ“Œ í•¨ìˆ˜: ClaudeClient.analyze_holding(...)

```python
async def analyze_holding(
    self,
    symbol: str,
    entry_price: float,
    current_price: float,
    current_pnl: float,
    holding_time: float,
    indicators: Dict,
    check_type: str
) -> Dict:
```

#### ì—­í• 
ë³´ìœ  ì¤‘ ì²­ì‚° íŒë‹¨ ìš”ì²­

#### ì¸ì
- `check_type: str` - 'TARGET_REACHED' | 'PERIODIC_CHECK'

#### ì‚¬ìš©í•˜ëŠ” ëª¨ë“ˆ/í•¨ìˆ˜
1. `prompts.generate_holding_prompt(...)` - í”„ë¡¬í”„íŠ¸ ìƒì„±
2. `self._call_api(prompt)` - API í˜¸ì¶œ
3. `self.analyzer.parse_response(raw)` - ì‘ë‹µ íŒŒì‹±

#### í˜¸ì¶œë˜ëŠ” ê³³
```python
# strategy/exit.py check_exit_signal()
# ëª©í‘œ ë„ë‹¬ ì‹œ
ai_response = await self.claude.analyze_holding(
    ...,
    check_type='TARGET_REACHED'
)

# ì •ê¸° ì²´í¬
ai_response = await self.claude.analyze_holding(
    ...,
    check_type='PERIODIC_CHECK'
)
```

#### ë°˜í™˜ê°’
```python
Dict:
    'action': str = 'EXIT' | 'HOLD'
    'confidence': float = 0.80
    'reasoning': str = "Momentum weakening, good exit point"
    'suggested_action': str = "Take profit now"
```

#### êµ¬í˜„ ì½”ë“œ
```python
async def analyze_holding(
    self,
    symbol: str,
    entry_price: float,
    current_price: float,
    current_pnl: float,
    holding_time: float,
    indicators: Dict,
    check_type: str
) -> Dict:
    """
    ë³´ìœ  ì¤‘ íŒë‹¨
    
    Args:
        check_type: 'TARGET_REACHED' or 'PERIODIC_CHECK'
    
    Returns:
        {
            'action': 'EXIT' or 'HOLD',
            'confidence': 0.80,
            'reasoning': '...'
        }
    """
    from .prompts import generate_holding_prompt
    
    prompt = generate_holding_prompt(
        symbol=symbol,
        entry_price=entry_price,
        current_price=current_price,
        current_pnl=current_pnl,
        holding_time=holding_time,
        indicators=indicators,
        check_type=check_type
    )
    
    raw_response = await self._call_api(prompt)
    parsed = self.analyzer.parse_response(raw_response)
    
    return parsed
```

---

### ğŸ“Œ í•¨ìˆ˜: ClaudeClient._call_api(prompt)

```python
async def _call_api(self, prompt: str) -> Dict:
```

#### ì—­í• 
Claude API ì‹¤ì œ í˜¸ì¶œ (ë‚´ë¶€ ë©”ì„œë“œ)

#### ì¸ì
- `prompt: str` - ì™„ì„±ëœ í”„ë¡¬í”„íŠ¸

#### ì‚¬ìš©í•˜ëŠ” ëª¨ë“ˆ/í•¨ìˆ˜
- `self.client.messages.create()` - Anthropic SDK

#### ì˜ˆì™¸ ì²˜ë¦¬
```python
- anthropic.RateLimitError â†’ 60ì´ˆ ëŒ€ê¸° í›„ ì¬ì‹œë„
- anthropic.APIError â†’ AIResponseErrorë¡œ ë³€í™˜
- anthropic.AuthenticationError â†’ ì¦‰ì‹œ ì¤‘ë‹¨
```

#### êµ¬í˜„ ì½”ë“œ
```python
async def _call_api(self, prompt: str) -> Dict:
    """
    Claude API í˜¸ì¶œ
    
    Raises:
        AIResponseError: API í˜¸ì¶œ ì‹¤íŒ¨
    """
    try:
        response = self.client.messages.create(
            model=self.model,
            max_tokens=self.max_tokens,
            temperature=self.temperature,
            messages=[
                {"role": "user", "content": prompt}
            ]
        )
        
        return {
            'content': response.content[0].text,
            'stop_reason': response.stop_reason
        }
    
    except anthropic.RateLimitError:
        # 1ë¶„ ëŒ€ê¸° í›„ ì¬ì‹œë„
        await asyncio.sleep(60)
        return await self._call_api(prompt)
    
    except anthropic.APIError as e:
        raise AIResponseError(f"Claude API ì˜¤ë¥˜: {e}")
    
    except anthropic.AuthenticationError:
        raise AIResponseError("Claude API í‚¤ ì¸ì¦ ì‹¤íŒ¨")
```

---

## ğŸ“ ai/analyzer.py

### íŒŒì¼ ì „ì²´ êµ¬ì¡°
```python
import json
import re
from typing import Dict
from core.exceptions import AIResponseError

class ResponseAnalyzer:
    def parse_response(self, raw_response: Dict) -> Dict: ...
    def _extract_json(self, text: str) -> str: ...
    def _validate_response(self, parsed: Dict) -> bool: ...
```

---

### ğŸ“Œ í•¨ìˆ˜: ResponseAnalyzer.parse_response(raw_response)

```python
def parse_response(self, raw_response: Dict) -> Dict:
```

#### ì—­í• 
Claude ì‘ë‹µì„ JSONìœ¼ë¡œ íŒŒì‹± ë° ê²€ì¦

#### ì¸ì
- `raw_response: Dict` - _call_api() ë°˜í™˜ê°’

#### ì²˜ë¦¬ íë¦„
```
1. content í…ìŠ¤íŠ¸ ì¶”ì¶œ
2. JSON ë¸”ë¡ ì°¾ê¸° (ì •ê·œì‹)
3. JSON íŒŒì‹±
4. í•„ìˆ˜ í•„ë“œ ê²€ì¦
5. íƒ€ì… ë³€í™˜ ë° ê²€ì¦
```

#### ë°˜í™˜ê°’
```python
Dict:
    'action': str
    'confidence': float
    'reasoning': str
    'key_factors': List[str] (ì„ íƒ)
```

#### ì˜ˆì™¸
- `AIResponseError` - íŒŒì‹± ì‹¤íŒ¨, ê²€ì¦ ì‹¤íŒ¨

#### êµ¬í˜„ ì½”ë“œ
```python
def parse_response(self, raw_response: Dict) -> Dict:
    """
    Claude ì‘ë‹µ íŒŒì‹±
    
    Returns:
        ê²€ì¦ëœ ì‘ë‹µ Dict
    
    Raises:
        AIResponseError: íŒŒì‹±/ê²€ì¦ ì‹¤íŒ¨
    """
    try:
        # 1. í…ìŠ¤íŠ¸ ì¶”ì¶œ
        content = raw_response['content']
        
        # 2. JSON ì¶”ì¶œ
        json_str = self._extract_json(content)
        
        # 3. íŒŒì‹±
        parsed = json.loads(json_str)
        
        # 4. ê²€ì¦
        if not self._validate_response(parsed):
            raise ValueError("í•„ìˆ˜ í•„ë“œ ëˆ„ë½")
        
        # 5. íƒ€ì… ë³€í™˜
        parsed['confidence'] = float(parsed['confidence'])
        
        if not 0 <= parsed['confidence'] <= 1:
            raise ValueError(f"ì‹ ë¢°ë„ ë²”ìœ„ ì˜¤ë¥˜: {parsed['confidence']}")
        
        return parsed
    
    except json.JSONDecodeError as e:
        raise AIResponseError(f"JSON íŒŒì‹± ì‹¤íŒ¨: {e}")
    
    except Exception as e:
        raise AIResponseError(f"ì‘ë‹µ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
```

---

### ğŸ“Œ í•¨ìˆ˜: ResponseAnalyzer._extract_json(text)

```python
def _extract_json(self, text: str) -> str:
```

#### ì—­í• 
í…ìŠ¤íŠ¸ì—ì„œ JSON ë¸”ë¡ ì¶”ì¶œ

#### ë¡œì§
```python
# íŒ¨í„´ 1: ```json ... ``` ë¸”ë¡
# íŒ¨í„´ 2: { ... } ì§ì ‘ ì°¾ê¸°
```

#### êµ¬í˜„ ì½”ë“œ
```python
def _extract_json(self, text: str) -> str:
    """í…ìŠ¤íŠ¸ì—ì„œ JSON ì¶”ì¶œ"""
    
    # íŒ¨í„´ 1: ```json ë¸”ë¡
    json_block = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
    if json_block:
        return json_block.group(1)
    
    # íŒ¨í„´ 2: { } ì§ì ‘ ì°¾ê¸°
    json_start = text.find('{')
    json_end = text.rfind('}')
    
    if json_start != -1 and json_end != -1:
        return text[json_start:json_end + 1]
    
    raise ValueError("JSON ë¸”ë¡ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ")
```

---

### ğŸ“Œ í•¨ìˆ˜: ResponseAnalyzer._validate_response(parsed)

```python
def _validate_response(self, parsed: Dict) -> bool:
```

#### ì—­í• 
í•„ìˆ˜ í•„ë“œ ê²€ì¦

#### ê²€ì¦ í•­ëª©
```python
required = ['action', 'confidence', 'reasoning']
valid_actions = ['ENTER', 'EXIT', 'HOLD', 'WAIT']
```

#### êµ¬í˜„ ì½”ë“œ
```python
def _validate_response(self, parsed: Dict) -> bool:
    """í•„ìˆ˜ í•„ë“œ ê²€ì¦"""
    
    required = ['action', 'confidence', 'reasoning']
    
    for field in required:
        if field not in parsed:
            return False
    
    valid_actions = ['ENTER', 'EXIT', 'HOLD', 'WAIT']
    if parsed['action'] not in valid_actions:
        return False
    
    return True
```

---

## ğŸ“ ai/prompts.py

### íŒŒì¼ ì „ì²´ êµ¬ì¡°
```python
from typing import Dict

def generate_entry_prompt(
    symbol: str,
    price: float,
    indicators: Dict,
    market_context: Dict
) -> str: ...

def generate_holding_prompt(
    symbol: str,
    entry_price: float,
    current_price: float,
    current_pnl: float,
    holding_time: float,
    indicators: Dict,
    check_type: str
) -> str: ...
```

---

### ğŸ“Œ í•¨ìˆ˜: generate_entry_prompt(...)

```python
def generate_entry_prompt(
    symbol: str,
    price: float,
    indicators: Dict,
    market_context: Dict
) -> str:
```

#### ì—­í• 
ì§„ì… íŒë‹¨ìš© í”„ë¡¬í”„íŠ¸ ìƒì„±

#### í”„ë¡¬í”„íŠ¸ êµ¬ì¡°
```
=== í˜„ì¬ ì‹œì¥ ë°ì´í„° ===
ì‹¬ë³¼: {symbol}
ê°€ê²©: ${price}
24h ë³€í™”: {change_24h}%

=== ê¸°ìˆ ì  ì§€í‘œ ===
RSI: {rsi} ({status})
MACD: {macd_status}
ë³¼ë¦°ì €: {bb_position}
í”¼ë³´ë‚˜ì¹˜: {fib_support}

=== ì‹œì¥ ë§¥ë½ ===
ê±°ë˜ëŸ‰: {volume_24h}
ë‰´ìŠ¤: {news_summary}

ê²°ì •í•˜ì„¸ìš”: ENTER or WAIT
JSON í˜•ì‹ìœ¼ë¡œ ì‘ë‹µí•˜ì„¸ìš”.
```

#### êµ¬í˜„ ì½”ë“œ
```python
def generate_entry_prompt(
    symbol: str,
    price: float,
    indicators: Dict,
    market_context: Dict
) -> str:
    """ì§„ì… íŒë‹¨ í”„ë¡¬í”„íŠ¸"""
    
    rsi = indicators['rsi']
    macd = indicators['macd']
    bb = indicators['bollinger']
    fib = indicators['fibonacci']
    
    prompt = f"""
=== í˜„ì¬ ì‹œì¥ ë°ì´í„° ===
ì‹¬ë³¼: {symbol}
ê°€ê²©: ${price}
24h ë³€í™”: {market_context.get('change_24h', 0)}%

=== ê¸°ìˆ ì  ì§€í‘œ ===
RSI: {rsi['value']} ({'ê³¼ë§¤ë„' if rsi['oversold'] else 'ì •ìƒ'})
MACD: {'ê³¨ë“  í¬ë¡œìŠ¤' if macd['golden_cross'] else macd['momentum']}
ë³¼ë¦°ì €ë°´ë“œ: {bb['position']} ({'í•˜ë‹¨ í„°ì¹˜' if bb['lower_touch'] else 'ì •ìƒ'})
í”¼ë³´ë‚˜ì¹˜: {'ì§€ì§€ì„  ê·¼ì²˜' if fib['at_support'] else 'ì •ìƒ'}

=== ì‹œì¥ ë§¥ë½ ===
24h ê±°ë˜ëŸ‰: {market_context.get('volume_24h', 0):,.0f}
ì‹ í˜¸ ê°œìˆ˜: {indicators['signal_count']}/4

ë‹¹ì‹ ì€ ì•”í˜¸í™”í ê±°ë˜ ì „ë¬¸ê°€ì…ë‹ˆë‹¤.
ìœ„ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì§„ì… ì—¬ë¶€ë¥¼ ê²°ì •í•˜ì„¸ìš”.

ì‘ë‹µì€ ë°˜ë“œì‹œ ë‹¤ìŒ JSON í˜•ì‹ìœ¼ë¡œ:
{{
    "action": "ENTER" or "WAIT",
    "confidence": 0.0-1.0,
    "reasoning": "íŒë‹¨ ì´ìœ ",
    "key_factors": ["macd", "volume"]
}}
"""
    
    return prompt
```

---

### ğŸ“Œ í•¨ìˆ˜: generate_holding_prompt(...)

```python
def generate_holding_prompt(
    symbol: str,
    entry_price: float,
    current_price: float,
    current_pnl: float,
    holding_time: float,
    indicators: Dict,
    check_type: str
) -> str:
```

#### ì—­í• 
ë³´ìœ  ì¤‘ íŒë‹¨ìš© í”„ë¡¬í”„íŠ¸ ìƒì„±

#### check_typeë³„ í”„ë¡¬í”„íŠ¸
```python
'TARGET_REACHED': "ëª©í‘œ +2% ë„ë‹¬, ê³„ì† ì˜¤ë¥¼ê¹Œìš”?"
'PERIODIC_CHECK': "2ì‹œê°„ ê²½ê³¼, ì²­ì‚°í• ê¹Œìš”?"
```

#### êµ¬í˜„ ì½”ë“œ
```python
def generate_holding_prompt(
    symbol: str,
    entry_price: float,
    current_price: float,
    current_pnl: float,
    holding_time: float,
    indicators: Dict,
    check_type: str
) -> str:
    """ë³´ìœ  ì¤‘ íŒë‹¨ í”„ë¡¬í”„íŠ¸"""
    
    holding_hours = holding_time / 3600
    
    context = {
        'TARGET_REACHED': f"ëª©í‘œ ìˆ˜ìµ +{current_pnl*100:.1f}% ë„ë‹¬! ê³„ì† ë³´ìœ í• ê¹Œìš”?",
        'PERIODIC_CHECK': f"ë³´ìœ  {holding_hours:.1f}ì‹œê°„ ê²½ê³¼. ì²­ì‚° ê²€í† "
    }
    
    prompt = f"""
=== í¬ì§€ì…˜ ì •ë³´ ===
ì‹¬ë³¼: {symbol}
ì§„ì…ê°€: ${entry_price}
í˜„ì¬ê°€: ${current_price}
ìˆ˜ìµë¥ : {current_pnl*100:+.2f}%
ë³´ìœ ì‹œê°„: {holding_hours:.1f}ì‹œê°„

=== í˜„ì¬ ì§€í‘œ ===
RSI: {indicators['rsi']['value']}
MACD ëª¨ë©˜í…€: {indicators['macd']['momentum']}

=== ìƒí™© ===
{context.get(check_type, 'ì •ê¸° ì²´í¬')}

íŒë‹¨í•˜ì„¸ìš”: EXIT or HOLD

ì‘ë‹µ JSON í˜•ì‹:
{{
    "action": "EXIT" or "HOLD",
    "confidence": 0.0-1.0,
    "reasoning": "íŒë‹¨ ì´ìœ "
}}
"""
    
    return prompt
```

---

## ğŸ“ ai/learner.py

### íŒŒì¼ ì „ì²´ êµ¬ì¡°
```python
from typing import Dict, List
from database import TradeDatabase

class AILearner:
    def __init__(self, db: TradeDatabase, claude: ClaudeClient): ...
    
    async def weekly_analysis(self) -> Dict: ...
    def _analyze_winning_patterns(self, trades: List[Dict]) -> List[Dict]: ...
    def _analyze_losing_patterns(self, trades: List[Dict]) -> List[Dict]: ...
```

---

### ğŸ“Œ í•¨ìˆ˜: AILearner.weekly_analysis()

```python
async def weekly_analysis(self) -> Dict:
```

#### ì—­í• 
ì£¼ê°„ í•™ìŠµ ì‚¬ì´í´ (ë§¤ì£¼ ì›”ìš”ì¼ ìë™)

#### ì²˜ë¦¬ íë¦„
```
1. ì§€ë‚œ 7ì¼ ê±°ë˜ ì¡°íšŒ
2. ìŠ¹ë¦¬ íŒ¨í„´ ë¶„ì„
3. ì‹¤íŒ¨ íŒ¨í„´ ë¶„ì„
4. AIì—ê²Œ ì¢…í•© ë¶„ì„ ìš”ì²­
5. íŒŒë¼ë¯¸í„° ì¡°ì • ì œì•ˆ
6. ë¦¬í¬íŠ¸ ìƒì„±
```

#### ë°˜í™˜ê°’
```python
Dict:
    'total_trades': int
    'win_rate': float
    'winning_patterns': List[Dict]
    'losing_patterns': List[Dict]
    'suggestions': Dict = {
        'rsi_threshold': 35,
        'min_confidence': 0.72,
        'preferred_hours': [2, 3, 14, 15]
    }
```

#### êµ¬í˜„ ì½”ë“œ
```python
async def weekly_analysis(self) -> Dict:
    """ì£¼ê°„ í•™ìŠµ ì‚¬ì´í´"""
    
    # 1. ê±°ë˜ ì¡°íšŒ
    trades = self.db.get_trades_last_7_days()
    
    # 2. íŒ¨í„´ ë¶„ì„
    winning = self._analyze_winning_patterns(trades)
    losing = self._analyze_losing_patterns(trades)
    
    # 3. AI ë¶„ì„ ìš”ì²­
    prompt = self._generate_learning_prompt(trades, winning, losing)
    ai_analysis = await self.claude._call_api(prompt)
    
    # 4. ì œì•ˆ íŒŒì‹±
    suggestions = self._parse_suggestions(ai_analysis)
    
    # 5. ë¦¬í¬íŠ¸ ìƒì„±
    report = {
        'total_trades': len(trades),
        'win_rate': self._calculate_win_rate(trades),
        'winning_patterns': winning,
        'losing_patterns': losing,
        'suggestions': suggestions
    }
    
    return report
```

---

## ğŸ“ ai/news_api.py (ì„ íƒ)

### íŒŒì¼ ì „ì²´ êµ¬ì¡°
```python
import aiohttp
from typing import List, Dict

class NewsCollector:
    async def get_recent_news(self, symbol: str) -> List[Dict]: ...
    async def get_fear_greed_index(self) -> Dict: ...
```

---

## ì „ì²´ ì˜ì¡´ì„± ê·¸ë˜í”„

### AI ëª¨ë“ˆ ë‚´ë¶€
```
claude_client.py
â”œâ”€â”€ import analyzer.py (ResponseAnalyzer)
â”œâ”€â”€ import prompts.py (generate_*)
â””â”€â”€ import core (APIKeys, exceptions)

analyzer.py
â””â”€â”€ import core (exceptions)

prompts.py
â””â”€â”€ (ë…ë¦½)

learner.py
â”œâ”€â”€ import claude_client.py
â””â”€â”€ import database
```

### ì‚¬ìš©í•˜ëŠ” ëª¨ë“ˆ
```
core/api_keys â†’ Claude API í‚¤
core/exceptions â†’ AIResponseError
database â†’ ê±°ë˜ ì´ë ¥
```

### ì‚¬ìš©ë˜ëŠ” ê³³
```
strategy/entry.py â†’ analyze_entry()
strategy/exit.py â†’ analyze_holding()
```

---

## ê°œë°œ ì²´í¬ë¦¬ìŠ¤íŠ¸

### claude_client.py
- [ ] ClaudeClient í´ë˜ìŠ¤
- [ ] __init__() - anthropic ì´ˆê¸°í™”
- [ ] analyze_entry() - ì§„ì… íŒë‹¨
- [ ] analyze_holding() - ë³´ìœ  íŒë‹¨
- [ ] _call_api() - ì‹¤ì œ API í˜¸ì¶œ
- [ ] ì˜ˆì™¸ ì²˜ë¦¬ (RateLimit, APIError)

### analyzer.py
- [ ] ResponseAnalyzer í´ë˜ìŠ¤
- [ ] parse_response() - JSON íŒŒì‹±
- [ ] _extract_json() - ì •ê·œì‹ ì¶”ì¶œ
- [ ] _validate_response() - í•„ë“œ ê²€ì¦

### prompts.py
- [ ] generate_entry_prompt()
- [ ] generate_holding_prompt()
- [ ] ëª…í™•í•œ ì§€ì‹œì‚¬í•­ í¬í•¨
- [ ] JSON í˜•ì‹ ìš”êµ¬

### learner.py
- [ ] AILearner í´ë˜ìŠ¤
- [ ] weekly_analysis() - ì£¼ê°„ ë¶„ì„
- [ ] íŒ¨í„´ ë¶„ì„ í•¨ìˆ˜ë“¤

---

## í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤

### claude_client.py í…ŒìŠ¤íŠ¸
```python
# 1. ì´ˆê¸°í™”
claude = ClaudeClient()

# 2. ì§„ì… íŒë‹¨ (Mock)
response = await claude.analyze_entry(
    symbol='DOGE/USDT',
    price=0.3821,
    indicators={...},
    market_context={...}
)
assert response['action'] in ['ENTER', 'WAIT']
assert 0 <= response['confidence'] <= 1

# 3. ë³´ìœ  íŒë‹¨
response = await claude.analyze_holding(
    ...,
    check_type='TARGET_REACHED'
)
assert response['action'] in ['EXIT', 'HOLD']
```

### analyzer.py í…ŒìŠ¤íŠ¸
```python
analyzer = ResponseAnalyzer()

# ì •ìƒ ì‘ë‹µ
raw = {
    'content': '```json\n{"action": "ENTER", "confidence": 0.75, "reasoning": "..."}\n```'
}
parsed = analyzer.parse_response(raw)
assert parsed['action'] == 'ENTER'

# íŒŒì‹± ì‹¤íŒ¨
try:
    analyzer.parse_response({'content': 'invalid'})
except AIResponseError:
    pass  # ì •ìƒ
```

---

## ì£¼ìš” íŠ¹ì§•

### 1. ë¹„ë™ê¸° ì²˜ë¦¬
- async/awaitë¡œ API ëŒ€ê¸° ìµœì†Œí™”
- Rate Limit ìë™ ì¬ì‹œë„

### 2. ê²¬ê³ í•œ íŒŒì‹±
- ì •ê·œì‹ìœ¼ë¡œ JSON ì¶”ì¶œ
- í•„ìˆ˜ í•„ë“œ ê²€ì¦
- íƒ€ì… ë³€í™˜ ë° ë²”ìœ„ ì²´í¬

### 3. í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§
- ëª…í™•í•œ ì§€ì‹œì‚¬í•­
- JSON í˜•ì‹ ê°•ì œ
- í•„ìˆ˜ í•„ë“œ ëª…ì‹œ

### 4. í•™ìŠµ ì‹œìŠ¤í…œ
- ì£¼ê°„ ìë™ ë¶„ì„
- íŒ¨í„´ ì¶”ì¶œ
- íŒŒë¼ë¯¸í„° ì œì•ˆ

---

**ë¬¸ì„œ ë²„ì „**: v1.0  
**ì‘ì„±ì¼**: 2025-01-15  
**Phase**: 4 (AI ë ˆì´ì–´)  
**ê²€ì¦**: âœ… ì™„ë£Œ