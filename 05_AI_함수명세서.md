# 05_AI 모듈 완벽 함수 명세서

> **목표**: 이 문서만으로 누구나 동일한 코드를 작성할 수 있다

---

## 📋 목차
1. [ai/claude_client.py](#aiclaudeclientpy)
2. [ai/analyzer.py](#aianalyzerpy)
3. [ai/prompts.py](#aiprompspy)
4. [ai/learner.py](#ailearnerpy)
5. [ai/news_api.py (선택)](#ainewsapipy)
6. [전체 의존성 그래프](#전체-의존성-그래프)

---

## 📁 ai/claude_client.py

### 파일 전체 구조
```python
import anthropic
import asyncio
from typing import Dict, Optional
from core.api_keys import APIKeys
from core.exceptions import AIResponseError
from .analyzer import ResponseAnalyzer

class ClaudeClient:
    def __init__(self): ...
    
    async def analyze_entry(
        self,
        symbol: str,
        price: float,
        indicators: Dict,
        market_context: Dict
    ) -> Dict: ...
    
    async def analyze_holding(
        self,
        symbol: str,
        entry_price: float,
        current_price: float,
        current_pnl: float,
        holding_time: float,
        indicators: Dict,
        check_type: str
    ) -> Dict: ...
    
    async def _call_api(self, prompt: str) -> Dict: ...
```

---

### 📌 클래스: ClaudeClient

#### 목적
Claude API 통신 및 응답 처리

---

### 📌 함수: ClaudeClient.__init__()

```python
def __init__(self):
```

#### 역할
Claude 클라이언트 초기화

#### 사용하는 모듈/함수
- `APIKeys.get_claude_config()` - API 키 및 설정
- `anthropic.Anthropic()` - Claude 클라이언트
- `ResponseAnalyzer()` - 응답 파싱기

#### 초기화 내용
```python
config = APIKeys.get_claude_config()
self.client = anthropic.Anthropic(api_key=config['api_key'])
self.model = config['model']
self.max_tokens = config['max_tokens']
self.temperature = config['temperature']
self.analyzer = ResponseAnalyzer()
```

#### 호출되는 곳
```python
# engine/base_engine.py __init__()
from ai import ClaudeClient

self.claude = ClaudeClient()
```

#### 구현 코드
```python
def __init__(self):
    """Claude 클라이언트 초기화"""
    config = APIKeys.get_claude_config()
    
    self.client = anthropic.Anthropic(
        api_key=config['api_key']
    )
    self.model = config['model']
    self.max_tokens = config['max_tokens']
    self.temperature = config['temperature']
    
    self.analyzer = ResponseAnalyzer()
```

---

### 📌 함수: ClaudeClient.analyze_entry(symbol, price, indicators, market_context)

```python
async def analyze_entry(
    self,
    symbol: str,
    price: float,
    indicators: Dict,
    market_context: Dict
) -> Dict:
```

#### 역할
진입 판단 요청

#### 인자
- `symbol: str` - 'DOGE/USDT'
- `price: float` - 현재가
- `indicators: Dict` - calculator.calculate_all() 결과
- `market_context: Dict` - 추가 시장 정보

#### 사용하는 모듈/함수
1. `prompts.generate_entry_prompt(...)` - 프롬프트 생성
2. `self._call_api(prompt)` - API 호출
3. `self.analyzer.parse_response(raw)` - 응답 파싱

#### 호출되는 곳
```python
# strategy/entry.py check_entry_signal()
ai_response = await self.claude.analyze_entry(
    symbol='DOGE/USDT',
    price=0.3821,
    indicators=indicators,
    market_context={...}
)
```

#### 반환값
```python
Dict:
    'action': str = 'ENTER' | 'WAIT'
    'confidence': float = 0.75  # 0-1
    'reasoning': str = "MACD golden cross with strong volume..."
    'key_factors': List[str] = ['macd', 'volume', 'rsi']
    'risk_level': str = 'MEDIUM'  # LOW, MEDIUM, HIGH
```

#### 구현 코드
```python
async def analyze_entry(
    self,
    symbol: str,
    price: float,
    indicators: Dict,
    market_context: Dict
) -> Dict:
    """
    진입 판단
    
    Returns:
        {
            'action': 'ENTER' or 'WAIT',
            'confidence': 0.75,
            'reasoning': '...',
            'key_factors': ['macd', 'volume']
        }
    """
    from .prompts import generate_entry_prompt
    
    # 프롬프트 생성
    prompt = generate_entry_prompt(
        symbol=symbol,
        price=price,
        indicators=indicators,
        market_context=market_context
    )
    
    # API 호출
    raw_response = await self._call_api(prompt)
    
    # 응답 파싱
    parsed = self.analyzer.parse_response(raw_response)
    
    return parsed
```

---

### 📌 함수: ClaudeClient.analyze_holding(...)

```python
async def analyze_holding(
    self,
    symbol: str,
    entry_price: float,
    current_price: float,
    current_pnl: float,
    holding_time: float,
    indicators: Dict,
    check_type: str
) -> Dict:
```

#### 역할
보유 중 청산 판단 요청

#### 인자
- `check_type: str` - 'TARGET_REACHED' | 'PERIODIC_CHECK'

#### 사용하는 모듈/함수
1. `prompts.generate_holding_prompt(...)` - 프롬프트 생성
2. `self._call_api(prompt)` - API 호출
3. `self.analyzer.parse_response(raw)` - 응답 파싱

#### 호출되는 곳
```python
# strategy/exit.py check_exit_signal()
# 목표 도달 시
ai_response = await self.claude.analyze_holding(
    ...,
    check_type='TARGET_REACHED'
)

# 정기 체크
ai_response = await self.claude.analyze_holding(
    ...,
    check_type='PERIODIC_CHECK'
)
```

#### 반환값
```python
Dict:
    'action': str = 'EXIT' | 'HOLD'
    'confidence': float = 0.80
    'reasoning': str = "Momentum weakening, good exit point"
    'suggested_action': str = "Take profit now"
```

#### 구현 코드
```python
async def analyze_holding(
    self,
    symbol: str,
    entry_price: float,
    current_price: float,
    current_pnl: float,
    holding_time: float,
    indicators: Dict,
    check_type: str
) -> Dict:
    """
    보유 중 판단
    
    Args:
        check_type: 'TARGET_REACHED' or 'PERIODIC_CHECK'
    
    Returns:
        {
            'action': 'EXIT' or 'HOLD',
            'confidence': 0.80,
            'reasoning': '...'
        }
    """
    from .prompts import generate_holding_prompt
    
    prompt = generate_holding_prompt(
        symbol=symbol,
        entry_price=entry_price,
        current_price=current_price,
        current_pnl=current_pnl,
        holding_time=holding_time,
        indicators=indicators,
        check_type=check_type
    )
    
    raw_response = await self._call_api(prompt)
    parsed = self.analyzer.parse_response(raw_response)
    
    return parsed
```

---

### 📌 함수: ClaudeClient._call_api(prompt)

```python
async def _call_api(self, prompt: str) -> Dict:
```

#### 역할
Claude API 실제 호출 (내부 메서드)

#### 인자
- `prompt: str` - 완성된 프롬프트

#### 사용하는 모듈/함수
- `self.client.messages.create()` - Anthropic SDK

#### 예외 처리
```python
- anthropic.RateLimitError → 60초 대기 후 재시도
- anthropic.APIError → AIResponseError로 변환
- anthropic.AuthenticationError → 즉시 중단
```

#### 구현 코드
```python
async def _call_api(self, prompt: str) -> Dict:
    """
    Claude API 호출
    
    Raises:
        AIResponseError: API 호출 실패
    """
    try:
        response = self.client.messages.create(
            model=self.model,
            max_tokens=self.max_tokens,
            temperature=self.temperature,
            messages=[
                {"role": "user", "content": prompt}
            ]
        )
        
        return {
            'content': response.content[0].text,
            'stop_reason': response.stop_reason
        }
    
    except anthropic.RateLimitError:
        # 1분 대기 후 재시도
        await asyncio.sleep(60)
        return await self._call_api(prompt)
    
    except anthropic.APIError as e:
        raise AIResponseError(f"Claude API 오류: {e}")
    
    except anthropic.AuthenticationError:
        raise AIResponseError("Claude API 키 인증 실패")
```

---

## 📁 ai/analyzer.py

### 파일 전체 구조
```python
import json
import re
from typing import Dict
from core.exceptions import AIResponseError

class ResponseAnalyzer:
    def parse_response(self, raw_response: Dict) -> Dict: ...
    def _extract_json(self, text: str) -> str: ...
    def _validate_response(self, parsed: Dict) -> bool: ...
```

---

### 📌 함수: ResponseAnalyzer.parse_response(raw_response)

```python
def parse_response(self, raw_response: Dict) -> Dict:
```

#### 역할
Claude 응답을 JSON으로 파싱 및 검증

#### 인자
- `raw_response: Dict` - _call_api() 반환값

#### 처리 흐름
```
1. content 텍스트 추출
2. JSON 블록 찾기 (정규식)
3. JSON 파싱
4. 필수 필드 검증
5. 타입 변환 및 검증
```

#### 반환값
```python
Dict:
    'action': str
    'confidence': float
    'reasoning': str
    'key_factors': List[str] (선택)
```

#### 예외
- `AIResponseError` - 파싱 실패, 검증 실패

#### 구현 코드
```python
def parse_response(self, raw_response: Dict) -> Dict:
    """
    Claude 응답 파싱
    
    Returns:
        검증된 응답 Dict
    
    Raises:
        AIResponseError: 파싱/검증 실패
    """
    try:
        # 1. 텍스트 추출
        content = raw_response['content']
        
        # 2. JSON 추출
        json_str = self._extract_json(content)
        
        # 3. 파싱
        parsed = json.loads(json_str)
        
        # 4. 검증
        if not self._validate_response(parsed):
            raise ValueError("필수 필드 누락")
        
        # 5. 타입 변환
        parsed['confidence'] = float(parsed['confidence'])
        
        if not 0 <= parsed['confidence'] <= 1:
            raise ValueError(f"신뢰도 범위 오류: {parsed['confidence']}")
        
        return parsed
    
    except json.JSONDecodeError as e:
        raise AIResponseError(f"JSON 파싱 실패: {e}")
    
    except Exception as e:
        raise AIResponseError(f"응답 처리 오류: {e}")
```

---

### 📌 함수: ResponseAnalyzer._extract_json(text)

```python
def _extract_json(self, text: str) -> str:
```

#### 역할
텍스트에서 JSON 블록 추출

#### 로직
```python
# 패턴 1: ```json ... ``` 블록
# 패턴 2: { ... } 직접 찾기
```

#### 구현 코드
```python
def _extract_json(self, text: str) -> str:
    """텍스트에서 JSON 추출"""
    
    # 패턴 1: ```json 블록
    json_block = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
    if json_block:
        return json_block.group(1)
    
    # 패턴 2: { } 직접 찾기
    json_start = text.find('{')
    json_end = text.rfind('}')
    
    if json_start != -1 and json_end != -1:
        return text[json_start:json_end + 1]
    
    raise ValueError("JSON 블록을 찾을 수 없음")
```

---

### 📌 함수: ResponseAnalyzer._validate_response(parsed)

```python
def _validate_response(self, parsed: Dict) -> bool:
```

#### 역할
필수 필드 검증

#### 검증 항목
```python
required = ['action', 'confidence', 'reasoning']
valid_actions = ['ENTER', 'EXIT', 'HOLD', 'WAIT']
```

#### 구현 코드
```python
def _validate_response(self, parsed: Dict) -> bool:
    """필수 필드 검증"""
    
    required = ['action', 'confidence', 'reasoning']
    
    for field in required:
        if field not in parsed:
            return False
    
    valid_actions = ['ENTER', 'EXIT', 'HOLD', 'WAIT']
    if parsed['action'] not in valid_actions:
        return False
    
    return True
```

---

## 📁 ai/prompts.py

### 파일 전체 구조
```python
from typing import Dict

def generate_entry_prompt(
    symbol: str,
    price: float,
    indicators: Dict,
    market_context: Dict
) -> str: ...

def generate_holding_prompt(
    symbol: str,
    entry_price: float,
    current_price: float,
    current_pnl: float,
    holding_time: float,
    indicators: Dict,
    check_type: str
) -> str: ...
```

---

### 📌 함수: generate_entry_prompt(...)

```python
def generate_entry_prompt(
    symbol: str,
    price: float,
    indicators: Dict,
    market_context: Dict
) -> str:
```

#### 역할
진입 판단용 프롬프트 생성

#### 프롬프트 구조
```
=== 현재 시장 데이터 ===
심볼: {symbol}
가격: ${price}
24h 변화: {change_24h}%

=== 기술적 지표 ===
RSI: {rsi} ({status})
MACD: {macd_status}
볼린저: {bb_position}
피보나치: {fib_support}

=== 시장 맥락 ===
거래량: {volume_24h}
뉴스: {news_summary}

결정하세요: ENTER or WAIT
JSON 형식으로 응답하세요.
```

#### 구현 코드
```python
def generate_entry_prompt(
    symbol: str,
    price: float,
    indicators: Dict,
    market_context: Dict
) -> str:
    """진입 판단 프롬프트"""
    
    rsi = indicators['rsi']
    macd = indicators['macd']
    bb = indicators['bollinger']
    fib = indicators['fibonacci']
    
    prompt = f"""
=== 현재 시장 데이터 ===
심볼: {symbol}
가격: ${price}
24h 변화: {market_context.get('change_24h', 0)}%

=== 기술적 지표 ===
RSI: {rsi['value']} ({'과매도' if rsi['oversold'] else '정상'})
MACD: {'골든 크로스' if macd['golden_cross'] else macd['momentum']}
볼린저밴드: {bb['position']} ({'하단 터치' if bb['lower_touch'] else '정상'})
피보나치: {'지지선 근처' if fib['at_support'] else '정상'}

=== 시장 맥락 ===
24h 거래량: {market_context.get('volume_24h', 0):,.0f}
신호 개수: {indicators['signal_count']}/4

당신은 암호화폐 거래 전문가입니다.
위 정보를 바탕으로 진입 여부를 결정하세요.

응답은 반드시 다음 JSON 형식으로:
{{
    "action": "ENTER" or "WAIT",
    "confidence": 0.0-1.0,
    "reasoning": "판단 이유",
    "key_factors": ["macd", "volume"]
}}
"""
    
    return prompt
```

---

### 📌 함수: generate_holding_prompt(...)

```python
def generate_holding_prompt(
    symbol: str,
    entry_price: float,
    current_price: float,
    current_pnl: float,
    holding_time: float,
    indicators: Dict,
    check_type: str
) -> str:
```

#### 역할
보유 중 판단용 프롬프트 생성

#### check_type별 프롬프트
```python
'TARGET_REACHED': "목표 +2% 도달, 계속 오를까요?"
'PERIODIC_CHECK': "2시간 경과, 청산할까요?"
```

#### 구현 코드
```python
def generate_holding_prompt(
    symbol: str,
    entry_price: float,
    current_price: float,
    current_pnl: float,
    holding_time: float,
    indicators: Dict,
    check_type: str
) -> str:
    """보유 중 판단 프롬프트"""
    
    holding_hours = holding_time / 3600
    
    context = {
        'TARGET_REACHED': f"목표 수익 +{current_pnl*100:.1f}% 도달! 계속 보유할까요?",
        'PERIODIC_CHECK': f"보유 {holding_hours:.1f}시간 경과. 청산 검토"
    }
    
    prompt = f"""
=== 포지션 정보 ===
심볼: {symbol}
진입가: ${entry_price}
현재가: ${current_price}
수익률: {current_pnl*100:+.2f}%
보유시간: {holding_hours:.1f}시간

=== 현재 지표 ===
RSI: {indicators['rsi']['value']}
MACD 모멘텀: {indicators['macd']['momentum']}

=== 상황 ===
{context.get(check_type, '정기 체크')}

판단하세요: EXIT or HOLD

응답 JSON 형식:
{{
    "action": "EXIT" or "HOLD",
    "confidence": 0.0-1.0,
    "reasoning": "판단 이유"
}}
"""
    
    return prompt
```

---

## 📁 ai/learner.py

### 파일 전체 구조
```python
from typing import Dict, List
from database import TradeDatabase

class AILearner:
    def __init__(self, db: TradeDatabase, claude: ClaudeClient): ...
    
    async def weekly_analysis(self) -> Dict: ...
    def _analyze_winning_patterns(self, trades: List[Dict]) -> List[Dict]: ...
    def _analyze_losing_patterns(self, trades: List[Dict]) -> List[Dict]: ...
```

---

### 📌 함수: AILearner.weekly_analysis()

```python
async def weekly_analysis(self) -> Dict:
```

#### 역할
주간 학습 사이클 (매주 월요일 자동)

#### 처리 흐름
```
1. 지난 7일 거래 조회
2. 승리 패턴 분석
3. 실패 패턴 분석
4. AI에게 종합 분석 요청
5. 파라미터 조정 제안
6. 리포트 생성
```

#### 반환값
```python
Dict:
    'total_trades': int
    'win_rate': float
    'winning_patterns': List[Dict]
    'losing_patterns': List[Dict]
    'suggestions': Dict = {
        'rsi_threshold': 35,
        'min_confidence': 0.72,
        'preferred_hours': [2, 3, 14, 15]
    }
```

#### 구현 코드
```python
async def weekly_analysis(self) -> Dict:
    """주간 학습 사이클"""
    
    # 1. 거래 조회
    trades = self.db.get_trades_last_7_days()
    
    # 2. 패턴 분석
    winning = self._analyze_winning_patterns(trades)
    losing = self._analyze_losing_patterns(trades)
    
    # 3. AI 분석 요청
    prompt = self._generate_learning_prompt(trades, winning, losing)
    ai_analysis = await self.claude._call_api(prompt)
    
    # 4. 제안 파싱
    suggestions = self._parse_suggestions(ai_analysis)
    
    # 5. 리포트 생성
    report = {
        'total_trades': len(trades),
        'win_rate': self._calculate_win_rate(trades),
        'winning_patterns': winning,
        'losing_patterns': losing,
        'suggestions': suggestions
    }
    
    return report
```

---

## 📁 ai/news_api.py (선택)

### 파일 전체 구조
```python
import aiohttp
from typing import List, Dict

class NewsCollector:
    async def get_recent_news(self, symbol: str) -> List[Dict]: ...
    async def get_fear_greed_index(self) -> Dict: ...
```

---

## 전체 의존성 그래프

### AI 모듈 내부
```
claude_client.py
├── import analyzer.py (ResponseAnalyzer)
├── import prompts.py (generate_*)
└── import core (APIKeys, exceptions)

analyzer.py
└── import core (exceptions)

prompts.py
└── (독립)

learner.py
├── import claude_client.py
└── import database
```

### 사용하는 모듈
```
core/api_keys → Claude API 키
core/exceptions → AIResponseError
database → 거래 이력
```

### 사용되는 곳
```
strategy/entry.py → analyze_entry()
strategy/exit.py → analyze_holding()
```

---

## 개발 체크리스트

### claude_client.py
- [ ] ClaudeClient 클래스
- [ ] __init__() - anthropic 초기화
- [ ] analyze_entry() - 진입 판단
- [ ] analyze_holding() - 보유 판단
- [ ] _call_api() - 실제 API 호출
- [ ] 예외 처리 (RateLimit, APIError)

### analyzer.py
- [ ] ResponseAnalyzer 클래스
- [ ] parse_response() - JSON 파싱
- [ ] _extract_json() - 정규식 추출
- [ ] _validate_response() - 필드 검증

### prompts.py
- [ ] generate_entry_prompt()
- [ ] generate_holding_prompt()
- [ ] 명확한 지시사항 포함
- [ ] JSON 형식 요구

### learner.py
- [ ] AILearner 클래스
- [ ] weekly_analysis() - 주간 분석
- [ ] 패턴 분석 함수들

---

## 테스트 시나리오

### claude_client.py 테스트
```python
# 1. 초기화
claude = ClaudeClient()

# 2. 진입 판단 (Mock)
response = await claude.analyze_entry(
    symbol='DOGE/USDT',
    price=0.3821,
    indicators={...},
    market_context={...}
)
assert response['action'] in ['ENTER', 'WAIT']
assert 0 <= response['confidence'] <= 1

# 3. 보유 판단
response = await claude.analyze_holding(
    ...,
    check_type='TARGET_REACHED'
)
assert response['action'] in ['EXIT', 'HOLD']
```

### analyzer.py 테스트
```python
analyzer = ResponseAnalyzer()

# 정상 응답
raw = {
    'content': '```json\n{"action": "ENTER", "confidence": 0.75, "reasoning": "..."}\n```'
}
parsed = analyzer.parse_response(raw)
assert parsed['action'] == 'ENTER'

# 파싱 실패
try:
    analyzer.parse_response({'content': 'invalid'})
except AIResponseError:
    pass  # 정상
```

---

## 주요 특징

### 1. 비동기 처리
- async/await로 API 대기 최소화
- Rate Limit 자동 재시도

### 2. 견고한 파싱
- 정규식으로 JSON 추출
- 필수 필드 검증
- 타입 변환 및 범위 체크

### 3. 프롬프트 엔지니어링
- 명확한 지시사항
- JSON 형식 강제
- 필수 필드 명시

### 4. 학습 시스템
- 주간 자동 분석
- 패턴 추출
- 파라미터 제안

---

**문서 버전**: v1.0  
**작성일**: 2025-01-15  
**Phase**: 4 (AI 레이어)  
**검증**: ✅ 완료