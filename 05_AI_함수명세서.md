# 05_AI ëª¨ë“ˆ ì™„ë²½ í•¨ìˆ˜ ëª…ì„¸ì„œ v2.0 (ê°œì„ íŒ)

> **ê°œì„ ì‚¬í•­**: learner.py í•¨ìˆ˜ êµ¬í˜„, í”„ë¡¬í”„íŠ¸ ê°•í™”, market_context êµ¬ì¡° ëª…ì„¸í™”

---

## ğŸ“‹ ëª©ì°¨
1. [ai/claude_client.py](#aiclaudeclientpy)
2. [ai/analyzer.py](#aianalyzerpy)
3. [ai/prompts.py](#aiprompspy) â­ ê°œì„ 
4. [ai/learner.py](#ailearnerpy) â­ ê°œì„ 
5. [ai/news_api.py (ì„ íƒ)](#ainewsapipy)
6. [ì „ì²´ ì˜ì¡´ì„± ê·¸ë˜í”„](#ì „ì²´-ì˜ì¡´ì„±-ê·¸ë˜í”„)
7. [ì‹¤ì „ ì‚¬ìš© ì˜ˆì œ](#ì‹¤ì „-ì‚¬ìš©-ì˜ˆì œ)

---

## ğŸ“ ai/claude_client.py

### íŒŒì¼ ì „ì²´ êµ¬ì¡°
```python
import anthropic
import asyncio
from typing import Dict, Optional
from core.api_keys import APIKeys
from core.exceptions import AIResponseError
from .analyzer import ResponseAnalyzer

class ClaudeClient:
    def __init__(self): ...
    
    async def analyze_entry(
        self,
        symbol: str,
        price: float,
        indicators: Dict,
        market_context: Dict
    ) -> Dict: ...
    
    async def analyze_holding(
        self,
        symbol: str,
        entry_price: float,
        current_price: float,
        current_pnl: float,
        holding_time: float,
        indicators: Dict,
        check_type: str
    ) -> Dict: ...
    
    async def _call_api(self, prompt: str) -> Dict: ...
```

---

### ğŸ“Œ í´ë˜ìŠ¤: ClaudeClient (ì „ì²´ êµ¬í˜„)

```python
import anthropic
import asyncio
from typing import Dict
from core.api_keys import APIKeys
from core.exceptions import AIResponseError
from .analyzer import ResponseAnalyzer


class ClaudeClient:
    """Claude API í†µì‹  ë° ì‘ë‹µ ì²˜ë¦¬"""
    
    def __init__(self):
        """Claude í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”"""
        config = APIKeys.get_claude_config()
        
        self.client = anthropic.Anthropic(
            api_key=config['api_key']
        )
        self.model = config['model']
        self.max_tokens = config['max_tokens']
        self.temperature = config['temperature']
        
        self.analyzer = ResponseAnalyzer()
    
    async def analyze_entry(
        self,
        symbol: str,
        price: float,
        indicators: Dict,
        market_context: Dict
    ) -> Dict:
        """
        ì§„ì… íŒë‹¨ ìš”ì²­
        
        Args:
            symbol: 'DOGE/USDT'
            price: í˜„ì¬ê°€
            indicators: calculator.calculate_all() ê²°ê³¼
            market_context: {
                'volume_24h': float,
                'change_24h': float,
                'additional_signals': Dict
            }
        
        Returns:
            {
                'action': 'ENTER' or 'WAIT',
                'confidence': 0.75,
                'reasoning': '...',
                'key_factors': ['macd', 'volume'],
                'risk_level': 'MEDIUM'
            }
        
        Raises:
            AIResponseError: API í˜¸ì¶œ ì‹¤íŒ¨
        """
        from .prompts import generate_entry_prompt
        
        # í”„ë¡¬í”„íŠ¸ ìƒì„±
        prompt = generate_entry_prompt(
            symbol=symbol,
            price=price,
            indicators=indicators,
            market_context=market_context
        )
        
        # API í˜¸ì¶œ
        raw_response = await self._call_api(prompt)
        
        # ì‘ë‹µ íŒŒì‹±
        parsed = self.analyzer.parse_response(raw_response)
        
        return parsed
    
    async def analyze_holding(
        self,
        symbol: str,
        entry_price: float,
        current_price: float,
        current_pnl: float,
        holding_time: float,
        indicators: Dict,
        check_type: str
    ) -> Dict:
        """
        ë³´ìœ  ì¤‘ ì²­ì‚° íŒë‹¨ ìš”ì²­
        
        Args:
            symbol: 'DOGE/USDT'
            entry_price: ì§„ì…ê°€
            current_price: í˜„ì¬ê°€
            current_pnl: í˜„ì¬ ì†ìµë¥ 
            holding_time: ë³´ìœ  ì‹œê°„ (ì´ˆ)
            indicators: calculator.calculate_all() ê²°ê³¼
            check_type: 'TARGET_REACHED' or 'PERIODIC_CHECK'
        
        Returns:
            {
                'action': 'EXIT' or 'HOLD',
                'confidence': 0.80,
                'reasoning': '...',
                'suggested_action': '...'
            }
        
        Raises:
            AIResponseError: API í˜¸ì¶œ ì‹¤íŒ¨
        """
        from .prompts import generate_holding_prompt
        
        prompt = generate_holding_prompt(
            symbol=symbol,
            entry_price=entry_price,
            current_price=current_price,
            current_pnl=current_pnl,
            holding_time=holding_time,
            indicators=indicators,
            check_type=check_type
        )
        
        raw_response = await self._call_api(prompt)
        parsed = self.analyzer.parse_response(raw_response)
        
        return parsed
    
    async def _call_api(self, prompt: str) -> Dict:
        """
        Claude API ì‹¤ì œ í˜¸ì¶œ (ë‚´ë¶€ ë©”ì„œë“œ)
        
        Args:
            prompt: ì™„ì„±ëœ í”„ë¡¬í”„íŠ¸
        
        Returns:
            {
                'content': '...',
                'stop_reason': 'end_turn'
            }
        
        Raises:
            AIResponseError: API í˜¸ì¶œ ì‹¤íŒ¨
        """
        try:
            response = self.client.messages.create(
                model=self.model,
                max_tokens=self.max_tokens,
                temperature=self.temperature,
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )
            
            return {
                'content': response.content[0].text,
                'stop_reason': response.stop_reason
            }
        
        except anthropic.RateLimitError:
            # 1ë¶„ ëŒ€ê¸° í›„ ì¬ì‹œë„
            await asyncio.sleep(60)
            return await self._call_api(prompt)
        
        except anthropic.APIError as e:
            raise AIResponseError(f"Claude API ì˜¤ë¥˜: {e}")
        
        except anthropic.AuthenticationError:
            raise AIResponseError("Claude API í‚¤ ì¸ì¦ ì‹¤íŒ¨")
        
        except Exception as e:
            raise AIResponseError(f"ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜: {e}")
```

---

## ğŸ“ ai/analyzer.py

### ì „ì²´ êµ¬í˜„ ì½”ë“œ

```python
import json
import re
from typing import Dict
from core.exceptions import AIResponseError


class ResponseAnalyzer:
    """Claude ì‘ë‹µ íŒŒì‹± ë° ê²€ì¦"""
    
    def parse_response(self, raw_response: Dict) -> Dict:
        """
        Claude ì‘ë‹µì„ JSONìœ¼ë¡œ íŒŒì‹± ë° ê²€ì¦
        
        Args:
            raw_response: _call_api() ë°˜í™˜ê°’
        
        Returns:
            ê²€ì¦ëœ ì‘ë‹µ Dict
        
        Raises:
            AIResponseError: íŒŒì‹±/ê²€ì¦ ì‹¤íŒ¨
        """
        try:
            # 1. í…ìŠ¤íŠ¸ ì¶”ì¶œ
            content = raw_response['content']
            
            # 2. JSON ì¶”ì¶œ
            json_str = self._extract_json(content)
            
            # 3. íŒŒì‹±
            parsed = json.loads(json_str)
            
            # 4. ê²€ì¦
            if not self._validate_response(parsed):
                raise ValueError("í•„ìˆ˜ í•„ë“œ ëˆ„ë½")
            
            # 5. íƒ€ì… ë³€í™˜
            parsed['confidence'] = float(parsed['confidence'])
            
            if not 0 <= parsed['confidence'] <= 1:
                raise ValueError(f"ì‹ ë¢°ë„ ë²”ìœ„ ì˜¤ë¥˜: {parsed['confidence']}")
            
            return parsed
        
        except json.JSONDecodeError as e:
            raise AIResponseError(f"JSON íŒŒì‹± ì‹¤íŒ¨: {e}")
        
        except Exception as e:
            raise AIResponseError(f"ì‘ë‹µ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
    
    def _extract_json(self, text: str) -> str:
        """
        í…ìŠ¤íŠ¸ì—ì„œ JSON ë¸”ë¡ ì¶”ì¶œ
        
        íŒ¨í„´:
        1. ```json ... ```
        2. { ... }
        """
        # íŒ¨í„´ 1: ```json ë¸”ë¡
        json_block = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
        if json_block:
            return json_block.group(1)
        
        # íŒ¨í„´ 2: { } ì§ì ‘ ì°¾ê¸°
        json_start = text.find('{')
        json_end = text.rfind('}')
        
        if json_start != -1 and json_end != -1:
            return text[json_start:json_end + 1]
        
        raise ValueError("JSON ë¸”ë¡ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ")
    
    def _validate_response(self, parsed: Dict) -> bool:
        """
        í•„ìˆ˜ í•„ë“œ ê²€ì¦
        
        ê²€ì¦ í•­ëª©:
        - action, confidence, reasoning í•„ìˆ˜
        - action ê°’ ì œí•œ
        """
        required = ['action', 'confidence', 'reasoning']
        
        for field in required:
            if field not in parsed:
                return False
        
        valid_actions = ['ENTER', 'EXIT', 'HOLD', 'WAIT']
        if parsed['action'] not in valid_actions:
            return False
        
        return True
```

---

## ğŸ“ ai/prompts.py â­ ê°œì„ 

### íŒŒì¼ ì „ì²´ êµ¬ì¡°
```python
from typing import Dict

def generate_entry_prompt(
    symbol: str,
    price: float,
    indicators: Dict,
    market_context: Dict
) -> str: ...

def generate_holding_prompt(
    symbol: str,
    entry_price: float,
    current_price: float,
    current_pnl: float,
    holding_time: float,
    indicators: Dict,
    check_type: str
) -> str: ...
```

---

### ğŸ“Œ í•¨ìˆ˜: generate_entry_prompt() â­ ê°œì„ 

```python
def generate_entry_prompt(
    symbol: str,
    price: float,
    indicators: Dict,
    market_context: Dict
) -> str:
    """
    â­ ì§„ì… íŒë‹¨ìš© í”„ë¡¬í”„íŠ¸ ìƒì„± (ê°œì„  - ë” ìƒì„¸í•˜ê²Œ)
    
    Args:
        symbol: 'DOGE/USDT'
        price: í˜„ì¬ê°€
        indicators: calculator.calculate_all() ê²°ê³¼
        market_context: {
            'volume_24h': float,
            'change_24h': float,
            'additional_signals': {
                'ema_aligned': bool,
                'volume_ratio': float,
                'stoch_rsi_up': bool
            }
        }
    
    Returns:
        í”„ë¡¬í”„íŠ¸ ë¬¸ìì—´ (~1000 tokens)
    """
    rsi = indicators['rsi']
    macd = indicators['macd']
    bb = indicators['bollinger']
    fib = indicators['fibonacci']
    additional = market_context.get('additional_signals', {})
    
    prompt = f"""ë‹¹ì‹ ì€ ì•”í˜¸í™”í ìë™ë§¤ë§¤ ì‹œìŠ¤í…œì˜ ì „ë¬¸ íŠ¸ë ˆì´ë”ì…ë‹ˆë‹¤.
í˜„ì¬ ì‹œì¥ ìƒí™©ì„ ë¶„ì„í•˜ê³  ì§„ì… ì—¬ë¶€ë¥¼ ê²°ì •í•˜ì„¸ìš”.

=== í˜„ì¬ ì‹œì¥ ë°ì´í„° ===
ì‹¬ë³¼: {symbol}
í˜„ì¬ê°€: ${price:.4f}
24h ë³€í™”: {market_context.get('change_24h', 0):+.2f}%
24h ê±°ë˜ëŸ‰: ${market_context.get('volume_24h', 0):,.0f}

=== ê¸°ìˆ ì  ì§€í‘œ ===
RSI(14): {rsi['value']:.2f}
  - ìƒíƒœ: {'ê³¼ë§¤ìˆ˜' if rsi['overbought'] else 'ê³¼ë§¤ë„' if rsi['oversold'] else 'ì •ìƒ'}
  - ì¶”ì„¸: {rsi['trend']}

MACD(12,26,9):
  - MACD: {macd['value']:.6f}
  - Signal: {macd['signal']:.6f}
  - Histogram: {macd['histogram']:.6f}
  - {'ğŸŸ¢ ê³¨ë“ í¬ë¡œìŠ¤!' if macd['golden_cross'] else 'ğŸ”´ ë°ë“œí¬ë¡œìŠ¤' if macd['death_cross'] else 'ì¤‘ë¦½'}
  - ëª¨ë©˜í…€: {macd['momentum']}

ë³¼ë¦°ì €ë°´ë“œ(20,2Ïƒ):
  - ìƒë‹¨: ${bb['upper']:.4f}
  - ì¤‘ê°„: ${bb['middle']:.4f}
  - í•˜ë‹¨: ${bb['lower']:.4f}
  - ìœ„ì¹˜: {bb['position']}
  - {'â­ í•˜ë‹¨ í„°ì¹˜!' if bb['lower_touch'] else ''}

í”¼ë³´ë‚˜ì¹˜:
  - í˜„ì¬ê°€: ${fib['current_price']:.4f}
  - ì§€ì§€ì„ : {fib['support'][0] if fib['support'] else 'N/A'} (${fib['support'][1]:.4f if fib['support'] else 0})
  - ì €í•­ì„ : {fib['resistance'][0] if fib['resistance'] else 'N/A'} (${fib['resistance'][1]:.4f if fib['resistance'] else 0})
  - {'â­ ì§€ì§€ì„  í„°ì¹˜!' if fib['at_support'] else ''}

ì§„ì… ì¡°ê±´ ì¶©ì¡±: {indicators['signal_count']}/4ê°œ

=== ì¶”ê°€ ì‹œê·¸ë„ ===
EMA ì •ë°°ì—´(20>50>200): {'âœ…' if additional.get('ema_aligned') else 'âŒ'}
ê±°ë˜ëŸ‰ ë¹„ìœ¨: {additional.get('volume_ratio', 1.0):.2f}ë°°
Stoch RSI ìƒìŠ¹: {'âœ…' if additional.get('stoch_rsi_up') else 'âŒ'}

=== ê±°ë˜ ê·œì¹™ ===
- ê¸°ìˆ ì  ì§€í‘œ ìµœì†Œ 3/4ê°œ ì¶©ì¡± í•„ìš”
- ì†ìµë¹„: ìµì ˆ +2%, ì†ì ˆ -1%
- íŠ¸ë ˆì¼ë§: +0.5% ë„ë‹¬ ì‹œ í™œì„±í™”
- ìµœëŒ€ ë³´ìœ : 24ì‹œê°„

=== ë‹¹ì‹ ì˜ ì„ë¬´ ===
ìœ„ ì •ë³´ë¥¼ ì¢…í•©í•˜ì—¬ ì§„ì… ì—¬ë¶€ë¥¼ ê²°ì •í•˜ì„¸ìš”.

ê³ ë ¤ì‚¬í•­:
1. ê¸°ìˆ ì  ì§€í‘œë“¤ì´ ì¼ì¹˜í•˜ëŠ”ê°€?
2. ë¦¬ìŠ¤í¬ ëŒ€ë¹„ ë³´ìƒì´ ì¶©ë¶„í•œê°€?
3. í˜„ì¬ ì‹œì¥ ëª¨ë©˜í…€ì€ ì–´ë– í•œê°€?
4. ìµœê·¼ ê°€ê²© ì›€ì§ì„ì— ë¹„ì •ìƒì ì¸ ì ì€ ì—†ëŠ”ê°€?

ë°˜ë“œì‹œ ë‹¤ìŒ JSON í˜•ì‹ìœ¼ë¡œ ì‘ë‹µí•˜ì„¸ìš”:
{{
    "action": "ENTER" or "WAIT",
    "confidence": 0.0~1.0,
    "reasoning": "íŒë‹¨ ê·¼ê±°ë¥¼ ëª…í™•í•˜ê²Œ ì„¤ëª…",
    "key_factors": ["macd", "volume", "rsi"],
    "risk_level": "LOW" or "MEDIUM" or "HIGH"
}}

ì‹ ë¢°ë„ ê¸°ì¤€:
- 0.90 ì´ìƒ: ë§¤ìš° ê°•í•œ ì‹ í˜¸, ëª¨ë“  ì¡°ê±´ ì™„ë²½
- 0.75~0.89: ê°•í•œ ì‹ í˜¸, ëŒ€ë¶€ë¶„ ì¡°ê±´ ì¶©ì¡±
- 0.70~0.74: ì–‘í˜¸í•œ ì‹ í˜¸, ê¸°ë³¸ ì¡°ê±´ ì¶©ì¡±
- 0.70 ë¯¸ë§Œ: WAIT (ì§„ì… ë³´ë¥˜)
"""
    
    return prompt


def generate_holding_prompt(
    symbol: str,
    entry_price: float,
    current_price: float,
    current_pnl: float,
    holding_time: float,
    indicators: Dict,
    check_type: str
) -> str:
    """
    â­ ë³´ìœ  ì¤‘ íŒë‹¨ìš© í”„ë¡¬í”„íŠ¸ ìƒì„± (ê°œì„  - ë” ìƒì„¸í•˜ê²Œ)
    
    Args:
        check_type: 'TARGET_REACHED' or 'PERIODIC_CHECK'
    
    Returns:
        í”„ë¡¬í”„íŠ¸ ë¬¸ìì—´ (~800 tokens)
    """
    holding_hours = holding_time / 3600
    holding_minutes = holding_time / 60
    
    rsi = indicators['rsi']
    macd = indicators['macd']
    
    context_messages = {
        'TARGET_REACHED': f"""
ğŸ¯ ëª©í‘œ ìˆ˜ìµ ë„ë‹¬!
í˜„ì¬ ìˆ˜ìµë¥ : +{current_pnl*100:.2f}%
ëª©í‘œ: +2.0%

ì§ˆë¬¸: ê³„ì† ì˜¤ë¥¼ ê°€ëŠ¥ì„±ì´ ìˆëŠ”ê°€? ì§€ê¸ˆ ì²­ì‚°í• ê¹Œ íŠ¸ë ˆì¼ë§ìœ¼ë¡œ ë” ê¸°ë‹¤ë¦´ê¹Œ?
""",
        'PERIODIC_CHECK': f"""
â° ì •ê¸° ì²´í¬ ì‹œì 
ë³´ìœ  ì‹œê°„: {holding_hours:.1f}ì‹œê°„ ê²½ê³¼

ì§ˆë¬¸: ê³„ì† ë³´ìœ í•  ê°€ì¹˜ê°€ ìˆëŠ”ê°€? ì¶”ì„¸ê°€ êº¾ì´ê³  ìˆëŠ”ê°€?
"""
    }
    
    prompt = f"""ë‹¹ì‹ ì€ ì•”í˜¸í™”í ìë™ë§¤ë§¤ ì‹œìŠ¤í…œì˜ ì „ë¬¸ íŠ¸ë ˆì´ë”ì…ë‹ˆë‹¤.
í˜„ì¬ ë³´ìœ  ì¤‘ì¸ í¬ì§€ì…˜ì˜ ì²­ì‚° ì—¬ë¶€ë¥¼ ê²°ì •í•˜ì„¸ìš”.

=== í¬ì§€ì…˜ ì •ë³´ ===
ì‹¬ë³¼: {symbol}
ì§„ì…ê°€: ${entry_price:.4f}
í˜„ì¬ê°€: ${current_price:.4f}
ìˆ˜ìµë¥ : {current_pnl*100:+.2f}%
ë³´ìœ  ì‹œê°„: {holding_hours:.1f}ì‹œê°„ ({holding_minutes:.0f}ë¶„)

=== í˜„ì¬ ì§€í‘œ ===
RSI: {rsi['value']:.2f} ({rsi['trend']} ì¶”ì„¸)
MACD ëª¨ë©˜í…€: {macd['momentum']}
MACD íˆìŠ¤í† ê·¸ë¨: {macd['histogram']:.6f}

=== ìƒí™© ===
{context_messages.get(check_type, 'ì •ê¸° ì²´í¬')}

=== ê±°ë˜ ê·œì¹™ ===
- íŠ¸ë ˆì¼ë§ ìŠ¤í†±: ê³ ì  -1%ì—ì„œ ìë™ ì²­ì‚°
- ìµœëŒ€ ë³´ìœ : 24ì‹œê°„ (ë‚¨ì€ ì‹œê°„: {24 - holding_hours:.1f}ì‹œê°„)
- ëª©í‘œ ìµì ˆ: +2%

=== ë‹¹ì‹ ì˜ ì„ë¬´ ===
ì§€ê¸ˆ ì²­ì‚°í• ì§€, ê³„ì† ë³´ìœ í• ì§€ ê²°ì •í•˜ì„¸ìš”.

ê³ ë ¤ì‚¬í•­:
1. ëª¨ë©˜í…€ì´ ì•½í™”ë˜ê³  ìˆëŠ”ê°€?
2. ì¶”ê°€ ìƒìŠ¹ ì—¬ë ¥ì´ ìˆëŠ”ê°€?
3. ì²­ì‚° ì‹œ íŠ¸ë ˆì¼ë§ìœ¼ë¡œ ë³´í˜¸í•  ìˆ˜ ìˆëŠ”ê°€?
4. ì‹œê°„ì´ ë„ˆë¬´ ì˜¤ë˜ ê²½ê³¼í–ˆëŠ”ê°€?

ë°˜ë“œì‹œ ë‹¤ìŒ JSON í˜•ì‹ìœ¼ë¡œ ì‘ë‹µí•˜ì„¸ìš”:
{{
    "action": "EXIT" or "HOLD",
    "confidence": 0.0~1.0,
    "reasoning": "íŒë‹¨ ê·¼ê±°ë¥¼ ëª…í™•í•˜ê²Œ ì„¤ëª…",
    "suggested_action": "ì§€ê¸ˆ ì²­ì‚°" or "íŠ¸ë ˆì¼ë§ìœ¼ë¡œ ê³„ì†"
}}

ì‹ ë¢°ë„ ê¸°ì¤€:
- EXIT ê¶Œì¥: 0.70 ì´ìƒ
- HOLD ê¶Œì¥: 0.70 ì´ìƒ
- ì• ë§¤í•œ ê²½ìš°: 0.50~0.69
"""
    
    return prompt
```

---

## ğŸ“ ai/learner.py â­ ê°œì„ 

### íŒŒì¼ ì „ì²´ êµ¬ì¡°
```python
from typing import Dict, List
from database import TradeDatabase
from ai import ClaudeClient

class AILearner:
    def __init__(self, db: TradeDatabase, claude: ClaudeClient): ...
    
    async def weekly_analysis(self) -> Dict: ...
    def _analyze_winning_patterns(self, trades: List[Dict]) -> List[Dict]: ...
    def _analyze_losing_patterns(self, trades: List[Dict]) -> List[Dict]: ...
    def _generate_learning_prompt(self, trades, winning, losing) -> str: ...  # â­ ì¶”ê°€
    def _parse_suggestions(self, ai_analysis: Dict) -> Dict: ...  # â­ ì¶”ê°€
    def _calculate_win_rate(self, trades: List[Dict]) -> float: ...  # â­ ì¶”ê°€
```

---

### ğŸ“Œ í´ë˜ìŠ¤: AILearner (ì „ì²´ êµ¬í˜„) â­

```python
from typing import Dict, List
import json
from database import TradeDatabase
from ai import ClaudeClient


class AILearner:
    """ì£¼ê°„ í•™ìŠµ ë° íŒ¨í„´ ë¶„ì„"""
    
    def __init__(self, db: TradeDatabase, claude: ClaudeClient):
        """
        ì´ˆê¸°í™”
        
        Args:
            db: ê±°ë˜ ë°ì´í„°ë² ì´ìŠ¤
            claude: Claude í´ë¼ì´ì–¸íŠ¸
        """
        self.db = db
        self.claude = claude
    
    async def weekly_analysis(self) -> Dict:
        """
        ì£¼ê°„ í•™ìŠµ ì‚¬ì´í´ (ë§¤ì£¼ ì›”ìš”ì¼ ìë™)
        
        Returns:
            {
                'total_trades': 15,
                'win_rate': 66.7,
                'winning_patterns': [...],
                'losing_patterns': [...],
                'suggestions': {
                    'rsi_threshold': 35,
                    'min_confidence': 0.72,
                    'preferred_hours': [2, 3, 14, 15]
                }
            }
        """
        print("\n=== ì£¼ê°„ í•™ìŠµ ì‚¬ì´í´ ì‹œì‘ ===")
        
        # 1. ê±°ë˜ ì¡°íšŒ
        trades = self.db.get_trades_last_7_days()
        print(f"ë¶„ì„ ëŒ€ìƒ: {len(trades)}ê±°ë˜")
        
        if len(trades) < 5:
            print("âš ï¸ ë°ì´í„° ë¶€ì¡± (ìµœì†Œ 5ê±°ë˜ í•„ìš”)")
            return {
                'total_trades': len(trades),
                'win_rate': 0,
                'winning_patterns': [],
                'losing_patterns': [],
                'suggestions': {}
            }
        
        # 2. íŒ¨í„´ ë¶„ì„
        winning = self._analyze_winning_patterns(trades)
        losing = self._analyze_losing_patterns(trades)
        
        print(f"ìŠ¹ë¦¬ íŒ¨í„´: {len(winning)}ê°œ")
        print(f"ì‹¤íŒ¨ íŒ¨í„´: {len(losing)}ê°œ")
        
        # 3. AI ë¶„ì„ ìš”ì²­
        prompt = self._generate_learning_prompt(trades, winning, losing)
        ai_analysis = await self.claude._call_api(prompt)
        
        # 4. ì œì•ˆ íŒŒì‹±
        suggestions = self._parse_suggestions(ai_analysis)
        
        # 5. ë¦¬í¬íŠ¸ ìƒì„±
        report = {
            'total_trades': len(trades),
            'win_rate': self._calculate_win_rate(trades),
            'winning_patterns': winning,
            'losing_patterns': losing,
            'suggestions': suggestions
        }
        
        print("=== ì£¼ê°„ í•™ìŠµ ì‚¬ì´í´ ì™„ë£Œ ===\n")
        
        return report
    
    def _analyze_winning_patterns(self, trades: List[Dict]) -> List[Dict]:
        """
        â­ ìŠ¹ë¦¬ íŒ¨í„´ ë¶„ì„ (êµ¬í˜„)
        
        Returns:
            [
                {
                    'pattern': 'RSI 30-40 + MACD ê³¨ë“ í¬ë¡œìŠ¤',
                    'count': 4,
                    'win_rate': 0.80,
                    'avg_profit': 0.028
                },
                ...
            ]
        """
        winning_trades = [t for t in trades if t.get('pnl_percent', 0) > 0]
        patterns = []
        
        # íŒ¨í„´ 1: RSI ë²”ìœ„ë³„
        rsi_ranges = [
            ('20-30', lambda t: 20 <= t.get('rsi_entry', 0) < 30),
            ('30-40', lambda t: 30 <= t.get('rsi_entry', 0) < 40),
            ('40-50', lambda t: 40 <= t.get('rsi_entry', 0) < 50)
        ]
        
        for range_name, condition in rsi_ranges:
            matched = [t for t in winning_trades if condition(t)]
            if len(matched) >= 2:
                patterns.append({
                    'pattern': f'RSI {range_name}',
                    'count': len(matched),
                    'win_rate': len(matched) / len([t for t in trades if condition(t)]) if len([t for t in trades if condition(t)]) > 0 else 0,
                    'avg_profit': sum(t['pnl_percent'] for t in matched) / len(matched)
                })
        
        # íŒ¨í„´ 2: MACD ìƒíƒœë³„
        macd_golden = [t for t in winning_trades if 'golden_cross' in str(t.get('macd_entry', ''))]
        if len(macd_golden) >= 2:
            patterns.append({
                'pattern': 'MACD ê³¨ë“ í¬ë¡œìŠ¤',
                'count': len(macd_golden),
                'win_rate': len(macd_golden) / len([t for t in trades if 'golden_cross' in str(t.get('macd_entry', ''))]),
                'avg_profit': sum(t['pnl_percent'] for t in macd_golden) / len(macd_golden)
            })
        
        # ìŠ¹ë¥  ë†’ì€ ìˆœìœ¼ë¡œ ì •ë ¬
        patterns.sort(key=lambda x: x['win_rate'], reverse=True)
        
        return patterns[:5]  # ìƒìœ„ 5ê°œë§Œ
    
    def _analyze_losing_patterns(self, trades: List[Dict]) -> List[Dict]:
        """
        â­ ì‹¤íŒ¨ íŒ¨í„´ ë¶„ì„ (êµ¬í˜„)
        
        Returns:
            [
                {
                    'pattern': 'RSI > 60 ì§„ì…',
                    'count': 3,
                    'loss_rate': 1.0,
                    'avg_loss': -0.008
                },
                ...
            ]
        """
        losing_trades = [t for t in trades if t.get('pnl_percent', 0) < 0]
        patterns = []
        
        # íŒ¨í„´ 1: RSI ê³ ì  ì§„ì…
        rsi_high = [t for t in losing_trades if t.get('rsi_entry', 0) > 60]
        if len(rsi_high) >= 2:
            patterns.append({
                'pattern': 'RSI > 60 ì§„ì…',
                'count': len(rsi_high),
                'loss_rate': len(rsi_high) / len([t for t in trades if t.get('rsi_entry', 0) > 60]),
                'avg_loss': sum(t['pnl_percent'] for t in rsi_high) / len(rsi_high)
            })
        
        # íŒ¨í„´ 2: ì €ê±°ë˜ëŸ‰ ì§„ì…
        low_volume = [t for t in losing_trades if t.get('volume_ratio', 1.0) < 1.2]
        if len(low_volume) >= 2:
            patterns.append({
                'pattern': 'ì €ê±°ë˜ëŸ‰ (< 1.2ë°°)',
                'count': len(low_volume),
                'loss_rate': len(low_volume) / len([t for t in trades if t.get('volume_ratio', 1.0) < 1.2]),
                'avg_loss': sum(t['pnl_percent'] for t in low_volume) / len(low_volume)
            })
        
        # ì†ì‹¤ë¥  ë†’ì€ ìˆœìœ¼ë¡œ ì •ë ¬
        patterns.sort(key=lambda x: x['loss_rate'], reverse=True)
        
        return patterns[:5]  # ìƒìœ„ 5ê°œë§Œ
    
    def _generate_learning_prompt(
        self,
        trades: List[Dict],
        winning: List[Dict],
        losing: List[Dict]
    ) -> str:
        """
        â­ í•™ìŠµìš© í”„ë¡¬í”„íŠ¸ ìƒì„± (ì¶”ê°€)
        
        Returns:
            í”„ë¡¬í”„íŠ¸ ë¬¸ìì—´
        """
        win_rate = self._calculate_win_rate(trades)
        
        prompt = f"""ë‹¹ì‹ ì€ ì•”í˜¸í™”í ìë™ë§¤ë§¤ ì‹œìŠ¤í…œì˜ ì„±ê³¼ë¥¼ ë¶„ì„í•˜ëŠ” ì „ë¬¸ê°€ì…ë‹ˆë‹¤.
ì§€ë‚œ 7ì¼ê°„ì˜ ê±°ë˜ ë°ì´í„°ë¥¼ ë¶„ì„í•˜ê³  ê°œì„  ë°©ì•ˆì„ ì œì‹œí•˜ì„¸ìš”.

=== ì „ì²´ ì„±ê³¼ ===
ì´ ê±°ë˜: {len(trades)}íšŒ
ìŠ¹ë¥ : {win_rate:.1f}%
ìŠ¹: {len([t for t in trades if t.get('pnl_percent', 0) > 0])}íšŒ
íŒ¨: {len([t for t in trades if t.get('pnl_percent', 0) < 0])}íšŒ

=== ìŠ¹ë¦¬ íŒ¨í„´ (ìƒìœ„ 5ê°œ) ===
{self._format_patterns(winning)}

=== ì‹¤íŒ¨ íŒ¨í„´ (ìƒìœ„ 5ê°œ) ===
{self._format_patterns(losing)}

=== ë‹¹ì‹ ì˜ ì„ë¬´ ===
ìœ„ ë°ì´í„°ë¥¼ ë¶„ì„í•˜ê³  ë‹¤ìŒì„ ì œì•ˆí•˜ì„¸ìš”:

1. ì§„ì… ì¡°ê±´ ì¡°ì •
   - RSI ì„ê³„ê°’ì„ ì–´ë–»ê²Œ ì¡°ì •í• ê¹Œ?
   - ìµœì†Œ AI ì‹ ë¢°ë„ë¥¼ ë†’ì—¬ì•¼ í• ê¹Œ?

2. ì‹œê°„ëŒ€ ì„ í˜¸
   - ì–´ëŠ ì‹œê°„ëŒ€ê°€ ìŠ¹ë¥ ì´ ë†’ì€ê°€?
   - í”¼í•´ì•¼ í•  ì‹œê°„ëŒ€ëŠ”?

3. ì¶”ê°€ íšŒí”¼ ì¡°ê±´
   - ì–´ë–¤ ì¡°ê±´ì—ì„œ ì§„ì…ì„ í”¼í•´ì•¼ í•˜ëŠ”ê°€?

ë°˜ë“œì‹œ ë‹¤ìŒ JSON í˜•ì‹ìœ¼ë¡œ ì‘ë‹µí•˜ì„¸ìš”:
{{
    "rsi_threshold": 30-50 ë²”ìœ„ì˜ ìˆ«ì,
    "min_confidence": 0.70-0.80 ë²”ìœ„ì˜ ìˆ«ì,
    "preferred_hours": [2, 3, 14, 15],
    "avoid_conditions": [
        "rsi > 65",
        "volume_ratio < 1.2"
    ],
    "reasoning": "ì œì•ˆ ê·¼ê±° ì„¤ëª…"
}}
"""
        return prompt
    
    def _format_patterns(self, patterns: List[Dict]) -> str:
        """íŒ¨í„´ì„ ë³´ê¸° ì¢‹ê²Œ í¬ë§·"""
        if not patterns:
            return "ì—†ìŒ"
        
        lines = []
        for p in patterns:
            if 'win_rate' in p:
                lines.append(f"- {p['pattern']}: {p['count']}íšŒ, ìŠ¹ë¥  {p['win_rate']*100:.1f}%")
            else:
                lines.append(f"- {p['pattern']}: {p['count']}íšŒ, ì†ì‹¤ë¥  {p['loss_rate']*100:.1f}%")
        
        return '\n'.join(lines)
    
    def _parse_suggestions(self, ai_analysis: Dict) -> Dict:
        """
        â­ AI ë¶„ì„ ê²°ê³¼ì—ì„œ ì œì•ˆì‚¬í•­ íŒŒì‹± (ì¶”ê°€)
        
        Returns:
            {
                'rsi_threshold': 35,
                'min_confidence': 0.72,
                'preferred_hours': [2, 3, 14, 15],
                'avoid_conditions': [...]
            }
        """
        try:
            content = ai_analysis['content']
            
            # JSON ì¶”ì¶œ
            json_start = content.find('{')
            json_end = content.rfind('}')
            
            if json_start != -1 and json_end != -1:
                json_str = content[json_start:json_end + 1]
                suggestions = json.loads(json_str)
                
                return suggestions
            
            return {}
        
        except Exception as e:
            print(f"âš ï¸ ì œì•ˆì‚¬í•­ íŒŒì‹± ì‹¤íŒ¨: {e}")
            return {}
    
    def _calculate_win_rate(self, trades: List[Dict]) -> float:
        """
        â­ ìŠ¹ë¥  ê³„ì‚° (ì¶”ê°€)
        
        Returns:
            ìŠ¹ë¥  (0-100)
        """
        if not trades:
            return 0.0
        
        wins = len([t for t in trades if t.get('pnl_percent', 0) > 0])
        return (wins / len(trades)) * 100
```

---

## ğŸ“ ai/news_api.py (ì„ íƒ)

### ê°„ë‹¨ êµ¬í˜„

```python
import aiohttp
from typing import List, Dict


class NewsCollector:
    """ë‰´ìŠ¤ ë° ì„¼í‹°ë¨¼íŠ¸ ìˆ˜ì§‘ (ì„ íƒ ê¸°ëŠ¥)"""
    
    async def get_recent_news(self, symbol: str) -> List[Dict]:
        """
        ìµœê·¼ 4ì‹œê°„ ë‰´ìŠ¤ ìˆ˜ì§‘
        
        Args:
            symbol: 'DOGE' or 'SOL'
        
        Returns:
            [
                {
                    'title': '...',
                    'sentiment': 'positive',
                    'published_at': '...'
                },
                ...
            ]
        """
        # CoinGecko API í˜¸ì¶œ
        # ì‹¤ì œ êµ¬í˜„ì€ í”„ë¡œì íŠ¸ ì§„í–‰ ì‹œ ì¶”ê°€
        return []
    
    async def get_fear_greed_index(self) -> Dict:
        """
        Fear & Greed Index ì¡°íšŒ
        
        Returns:
            {
                'value': 65,
                'classification': 'Greed'
            }
        """
        # Alternative.me API í˜¸ì¶œ
        # ì‹¤ì œ êµ¬í˜„ì€ í”„ë¡œì íŠ¸ ì§„í–‰ ì‹œ ì¶”ê°€
        return {
            'value': 50,
            'classification': 'Neutral'
        }
```

---

## ì „ì²´ ì˜ì¡´ì„± ê·¸ë˜í”„

```
ai/
â”œâ”€â”€ claude_client.py
â”‚   â”œâ”€â”€ import analyzer.py
â”‚   â”œâ”€â”€ import prompts.py
â”‚   â””â”€â”€ import core
â”‚
â”œâ”€â”€ analyzer.py
â”‚   â””â”€â”€ import core
â”‚
â”œâ”€â”€ prompts.py (ë…ë¦½)
â”‚
â”œâ”€â”€ learner.py
â”‚   â”œâ”€â”€ import claude_client.py
â”‚   â””â”€â”€ import database
â”‚
â””â”€â”€ news_api.py (ì„ íƒ, ë…ë¦½)

ì‚¬ìš©í•˜ëŠ” ëª¨ë“ˆ:
- core/api_keys, exceptions
- database/TradeDatabase

ì‚¬ìš©ë˜ëŠ” ê³³:
- strategy/entry.py â†’ analyze_entry()
- strategy/exit.py â†’ analyze_holding()
```

---

## ì‹¤ì „ ì‚¬ìš© ì˜ˆì œ

### ì˜ˆì œ 1: ì§„ì… ë¶„ì„

```python
from ai import ClaudeClient

claude = ClaudeClient()

# ì§„ì… ë¶„ì„
response = await claude.analyze_entry(
    symbol='DOGE/USDT',
    price=0.3821,
    indicators=indicators,
    market_context={
        'volume_24h': 1234567890,
        'change_24h': 2.5,
        'additional_signals': {
            'ema_aligned': True,
            'volume_ratio': 1.8,
            'stoch_rsi_up': True
        }
    }
)

print(f"íŒë‹¨: {response['action']}")
print(f"ì‹ ë¢°ë„: {response['confidence']}")
print(f"ì´ìœ : {response['reasoning']}")
```

### ì˜ˆì œ 2: ì£¼ê°„ í•™ìŠµ

```python
from ai import AILearner
from database import TradeDatabase

db = TradeDatabase()
learner = AILearner(db, claude)

# ì£¼ê°„ ë¶„ì„
report = await learner.weekly_analysis()

print(f"ì´ ê±°ë˜: {report['total_trades']}")
print(f"ìŠ¹ë¥ : {report['win_rate']:.1f}%")
print(f"\nì œì•ˆì‚¬í•­:")
print(json.dumps(report['suggestions'], indent=2, ensure_ascii=False))
```

---

## ê°œë°œ ì²´í¬ë¦¬ìŠ¤íŠ¸

### claude_client.py
- [x] ClaudeClient í´ë˜ìŠ¤
- [x] __init__() - anthropic ì´ˆê¸°í™”
- [x] analyze_entry()
- [x] analyze_holding()
- [x] _call_api() - ì˜ˆì™¸ ì²˜ë¦¬

### analyzer.py
- [x] ResponseAnalyzer í´ë˜ìŠ¤
- [x] parse_response()
- [x] _extract_json()
- [x] _validate_response()

### prompts.py â­
- [x] generate_entry_prompt() â­ ìƒì„¸í™”
- [x] generate_holding_prompt() â­ ìƒì„¸í™”
- [x] market_context êµ¬ì¡° ëª…ì„¸í™”

### learner.py â­
- [x] AILearner í´ë˜ìŠ¤
- [x] weekly_analysis()
- [x] _analyze_winning_patterns() â­ êµ¬í˜„
- [x] _analyze_losing_patterns() â­ êµ¬í˜„
- [x] _generate_learning_prompt() â­ ì¶”ê°€
- [x] _parse_suggestions() â­ ì¶”ê°€
- [x] _calculate_win_rate() â­ ì¶”ê°€

### news_api.py (ì„ íƒ)
- [x] NewsCollector í´ë˜ìŠ¤ (ìŠ¤í…)
- [ ] ì‹¤ì œ API ì—°ë™ (í–¥í›„)

---

**ë¬¸ì„œ ë²„ì „**: v2.0 (ê°œì„ íŒ)  
**ì‘ì„±ì¼**: 2025-01-21  
**ê°œì„ ì‚¬í•­**: 
- â­ generate_entry_prompt() ìƒì„¸í™” (~1000 tokens)
- â­ generate_holding_prompt() ìƒì„¸í™” (~800 tokens)
- â­ market_context êµ¬ì¡° ëª…ì„¸í™”
- â­ learner.py ëª¨ë“  í•¨ìˆ˜ êµ¬í˜„
- â­ _generate_learning_prompt() ì¶”ê°€
- â­ _parse_suggestions() ì¶”ê°€
- â­ _calculate_win_rate() ì¶”ê°€
- âœ… íŒ¨í„´ ë¶„ì„ ë¡œì§ ì™„ì„±

**ê²€ì¦ ìƒíƒœ**: âœ… ì™„ë£Œ
